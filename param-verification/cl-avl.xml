<?xml version="1.0" encoding="UTF-8"?>
<registry>
    <!-- SECTION: OpenCL API interface definitions -->
    <feature api="opencl" name="CL_VERSION_1_0" number="1.0" comment="OpenCL core API interface definitions">
        <require comment="Header boilerplate">
            <type name="CL/cl_version.h"/>
            <type name="CL/cl_platform.h"/>
        </require>
        <require comment="API types">
            <type name="cl_platform_id"/>
            <type name="cl_device_id"/>
            <type name="cl_context"/>
            <type name="cl_command_queue"/>
            <type name="cl_mem"/>
            <type name="cl_program"/>
            <type name="cl_kernel"/>
            <type name="cl_event"/>
            <type name="cl_sampler"/>
            <type name="cl_bool" comment="WARNING! Unlike cl_ types in cl_platform.h, cl_bool is not guaranteed to be the same size as the bool in kernels."/>
            <type name="cl_bitfield"/>
            <type name="cl_device_type"/>
            <type name="cl_platform_info"/>
            <type name="cl_device_info"/>
            <type name="cl_device_fp_config"/>
            <type name="cl_device_mem_cache_type"/>
            <type name="cl_device_local_mem_type"/>
            <type name="cl_device_exec_capabilities"/>
            <type name="cl_command_queue_properties"/>
            <type name="cl_context_properties"/>
            <type name="cl_context_info"/>
            <type name="cl_command_queue_info"/>
            <type name="cl_channel_order"/>
            <type name="cl_channel_type"/>
            <type name="cl_mem_flags"/>
            <type name="cl_mem_object_type"/>
            <type name="cl_mem_info"/>
            <type name="cl_image_info"/>
            <type name="cl_addressing_mode"/>
            <type name="cl_filter_mode"/>
            <type name="cl_sampler_info"/>
            <type name="cl_map_flags"/>
            <type name="cl_program_info"/>
            <type name="cl_program_build_info"/>
            <type name="cl_build_status"/>
            <type name="cl_kernel_info"/>
            <type name="cl_kernel_work_group_info"/>
            <type name="cl_event_info"/>
            <type name="cl_command_type"/>
            <type name="cl_profiling_info"/>
            <type name="cl_image_format"/>
            <type name="cl_buffer_region"/>
        </require>
        <require comment="Constants">
            <enum name="CL_CHAR_BIT"/>
            <enum name="CL_CHAR_MAX"/>
            <enum name="CL_CHAR_MIN"/>
            <enum name="CL_UCHAR_MAX"/>
            <enum name="CL_SCHAR_MAX"/>
            <enum name="CL_SCHAR_MIN"/>
            <enum name="CL_SHRT_MAX"/>
            <enum name="CL_SHRT_MIN"/>
            <enum name="CL_USHRT_MAX"/>
            <enum name="CL_INT_MAX"/>
            <enum name="CL_INT_MIN"/>
            <enum name="CL_UINT_MAX"/>
            <enum name="CL_LONG_MAX"/>
            <enum name="CL_LONG_MIN"/>
            <enum name="CL_ULONG_MAX"/>
            <enum name="CL_FLT_DIG"/>
            <enum name="CL_FLT_MANT_DIG"/>
            <enum name="CL_FLT_MAX_10_EXP"/>
            <enum name="CL_FLT_MAX_EXP"/>
            <enum name="CL_FLT_MIN_10_EXP"/>
            <enum name="CL_FLT_MIN_EXP"/>
            <enum name="CL_FLT_RADIX"/>
            <enum name="CL_FLT_MAX"/>
            <enum name="CL_FLT_MIN"/>
            <enum name="CL_FLT_EPSILON"/>
            <enum name="CL_DBL_DIG"/>
            <enum name="CL_DBL_MANT_DIG"/>
            <enum name="CL_DBL_MAX_10_EXP"/>
            <enum name="CL_DBL_MAX_EXP"/>
            <enum name="CL_DBL_MIN_10_EXP"/>
            <enum name="CL_DBL_MIN_EXP"/>
            <enum name="CL_DBL_RADIX"/>
            <enum name="CL_DBL_MAX"/>
            <enum name="CL_DBL_MIN"/>
            <enum name="CL_DBL_EPSILON"/>
            <enum name="CL_NAN"/>
            <enum name="CL_HUGE_VALF"/>
            <enum name="CL_HUGE_VAL"/>
            <enum name="CL_MAXFLOAT"/>
            <enum name="CL_INFINITY"/>
        </require>
        <require comment="Error codes">
            <enum name="CL_SUCCESS"/>
            <enum name="CL_DEVICE_NOT_FOUND"/>
            <enum name="CL_DEVICE_NOT_AVAILABLE"/>
            <enum name="CL_COMPILER_NOT_AVAILABLE"/>
            <enum name="CL_MEM_OBJECT_ALLOCATION_FAILURE"/>
            <enum name="CL_OUT_OF_RESOURCES"/>
            <enum name="CL_OUT_OF_HOST_MEMORY"/>
            <enum name="CL_PROFILING_INFO_NOT_AVAILABLE"/>
            <enum name="CL_MEM_COPY_OVERLAP"/>
            <enum name="CL_IMAGE_FORMAT_MISMATCH"/>
            <enum name="CL_IMAGE_FORMAT_NOT_SUPPORTED"/>
            <enum name="CL_BUILD_PROGRAM_FAILURE"/>
            <enum name="CL_MAP_FAILURE"/>
            <enum name="CL_INVALID_VALUE"/>
            <enum name="CL_INVALID_DEVICE_TYPE"/>
            <enum name="CL_INVALID_PLATFORM"/>
            <enum name="CL_INVALID_DEVICE"/>
            <enum name="CL_INVALID_CONTEXT"/>
            <enum name="CL_INVALID_QUEUE_PROPERTIES"/>
            <enum name="CL_INVALID_COMMAND_QUEUE"/>
            <enum name="CL_INVALID_HOST_PTR"/>
            <enum name="CL_INVALID_MEM_OBJECT"/>
            <enum name="CL_INVALID_IMAGE_FORMAT_DESCRIPTOR"/>
            <enum name="CL_INVALID_IMAGE_SIZE"/>
            <enum name="CL_INVALID_SAMPLER"/>
            <enum name="CL_INVALID_BINARY"/>
            <enum name="CL_INVALID_BUILD_OPTIONS"/>
            <enum name="CL_INVALID_PROGRAM"/>
            <enum name="CL_INVALID_PROGRAM_EXECUTABLE"/>
            <enum name="CL_INVALID_KERNEL_NAME"/>
            <enum name="CL_INVALID_KERNEL_DEFINITION"/>
            <enum name="CL_INVALID_KERNEL"/>
            <enum name="CL_INVALID_ARG_INDEX"/>
            <enum name="CL_INVALID_ARG_VALUE"/>
            <enum name="CL_INVALID_ARG_SIZE"/>
            <enum name="CL_INVALID_KERNEL_ARGS"/>
            <enum name="CL_INVALID_WORK_DIMENSION"/>
            <enum name="CL_INVALID_WORK_GROUP_SIZE"/>
            <enum name="CL_INVALID_WORK_ITEM_SIZE"/>
            <enum name="CL_INVALID_GLOBAL_OFFSET"/>
            <enum name="CL_INVALID_EVENT_WAIT_LIST"/>
            <enum name="CL_INVALID_EVENT"/>
            <enum name="CL_INVALID_OPERATION"/>
            <enum name="CL_INVALID_GL_OBJECT"/>
            <enum name="CL_INVALID_BUFFER_SIZE"/>
            <enum name="CL_INVALID_MIP_LEVEL"/>
            <enum name="CL_INVALID_GLOBAL_WORK_SIZE"/>
        </require>
        <require comment="cl_bool">
            <enum name="CL_FALSE"/>
            <enum name="CL_TRUE"/>
        </require>
        <require comment="cl_platform_info">
            <enum name="CL_PLATFORM_PROFILE" return_type="char[]"/>
            <enum name="CL_PLATFORM_VERSION" return_type="char[]"/>
            <enum name="CL_PLATFORM_NAME" return_type="char[]"/>
            <enum name="CL_PLATFORM_VENDOR" return_type="char[]"/>
            <enum name="CL_PLATFORM_EXTENSIONS" return_type="char[]"/>
        </require>
        <require comment="cl_device_type - bitfield">
            <enum name="CL_DEVICE_TYPE_DEFAULT"/>
            <enum name="CL_DEVICE_TYPE_CPU"/>
            <enum name="CL_DEVICE_TYPE_GPU"/>
            <enum name="CL_DEVICE_TYPE_ACCELERATOR"/>
            <enum name="CL_DEVICE_TYPE_ALL"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_TYPE" return_type="cl_device_type"/>
            <enum name="CL_DEVICE_VENDOR_ID" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_COMPUTE_UNITS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_WORK_GROUP_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_MAX_WORK_ITEM_SIZES" return_type="size_t[]"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_CLOCK_FREQUENCY" return_type="cl_uint"/>
            <enum name="CL_DEVICE_ADDRESS_BITS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_READ_IMAGE_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_WRITE_IMAGE_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_MEM_ALLOC_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_IMAGE2D_MAX_WIDTH" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE2D_MAX_HEIGHT" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE3D_MAX_WIDTH" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE3D_MAX_HEIGHT" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE3D_MAX_DEPTH" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_MAX_PARAMETER_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_MAX_SAMPLERS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MEM_BASE_ADDR_ALIGN" return_type="cl_uint"/>
            <enum name="CL_DEVICE_SINGLE_FP_CONFIG" return_type="cl_device_fp_config"/>
            <enum name="CL_DEVICE_GLOBAL_MEM_CACHE_TYPE" return_type="cl_device_mem_cache_type"/>
            <enum name="CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_GLOBAL_MEM_CACHE_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_GLOBAL_MEM_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_MAX_CONSTANT_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_LOCAL_MEM_TYPE" return_type="cl_device_local_mem_type"/>
            <enum name="CL_DEVICE_LOCAL_MEM_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_ERROR_CORRECTION_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_PROFILING_TIMER_RESOLUTION" return_type="size_t"/>
            <enum name="CL_DEVICE_ENDIAN_LITTLE" return_type="cl_bool"/>
            <enum name="CL_DEVICE_AVAILABLE" return_type="cl_bool"/>
            <enum name="CL_DEVICE_COMPILER_AVAILABLE" return_type="cl_bool"/>
            <enum name="CL_DEVICE_EXECUTION_CAPABILITIES" return_type="cl_device_exec_capabilities"/>
            <enum name="CL_DEVICE_NAME" return_type="char[]"/>
            <enum name="CL_DEVICE_VENDOR" return_type="char[]"/>
            <enum name="CL_DRIVER_VERSION" return_type="char[]"/>
            <enum name="CL_DEVICE_PROFILE" return_type="char[]"/>
            <enum name="CL_DEVICE_VERSION" return_type="char[]"/>
            <enum name="CL_DEVICE_EXTENSIONS" return_type="char[]"/>
            <enum name="CL_DEVICE_PLATFORM" return_type="cl_platform_id"/>
        </require>
        <require comment="cl_device_fp_config - bitfield">
            <enum name="CL_FP_DENORM"/>
            <enum name="CL_FP_INF_NAN"/>
            <enum name="CL_FP_ROUND_TO_NEAREST"/>
            <enum name="CL_FP_ROUND_TO_ZERO"/>
            <enum name="CL_FP_ROUND_TO_INF"/>
            <enum name="CL_FP_FMA"/>
        </require>
        <require comment="cl_device_mem_cache_type">
            <enum name="CL_NONE"/>
            <enum name="CL_READ_ONLY_CACHE"/>
            <enum name="CL_READ_WRITE_CACHE"/>
        </require>
        <require comment="cl_device_local_mem_type">
            <enum name="CL_LOCAL"/>
            <enum name="CL_GLOBAL"/>
        </require>
        <require comment="cl_device_exec_capabilities - bitfield">
            <enum name="CL_EXEC_KERNEL"/>
            <enum name="CL_EXEC_NATIVE_KERNEL"/>
        </require>
        <require comment="cl_command_queue_properties - bitfield">
            <enum name="CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE"/>
            <enum name="CL_QUEUE_PROFILING_ENABLE"/>
        </require>
        <require comment="cl_context_info">
            <enum name="CL_CONTEXT_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_CONTEXT_DEVICES" return_type="cl_device_id[]"/>
            <enum name="CL_CONTEXT_PROPERTIES" return_type="cl_context_properties[]"/>
        </require>
        <require comment="cl_context_properties">
            <enum name="CL_CONTEXT_PLATFORM"/>
        </require>
        <require comment="cl_command_queue_info">
            <enum name="CL_QUEUE_CONTEXT" return_type="cl_context"/>
            <enum name="CL_QUEUE_DEVICE" return_type="cl_device_id"/>
            <enum name="CL_QUEUE_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_QUEUE_PROPERTIES" return_type="cl_command_queue_properties"/>
        </require>
        <require comment="cl_mem_flags and cl_svm_mem_flags - bitfield">
            <enum name="CL_MEM_READ_WRITE"/>
            <enum name="CL_MEM_WRITE_ONLY"/>
            <enum name="CL_MEM_READ_ONLY"/>
            <enum name="CL_MEM_USE_HOST_PTR"/>
            <enum name="CL_MEM_ALLOC_HOST_PTR"/>
            <enum name="CL_MEM_COPY_HOST_PTR"/>
        </require>
        <require comment="cl_profiling_info">
            <enum name="CL_PROFILING_COMMAND_QUEUED" return_type="cl_ulong"/>
            <enum name="CL_PROFILING_COMMAND_SUBMIT" return_type="cl_ulong"/>
            <enum name="CL_PROFILING_COMMAND_START" return_type="cl_ulong"/>
            <enum name="CL_PROFILING_COMMAND_END" return_type="cl_ulong"/>
        </require>
        <require comment="cl_channel_order">
            <enum name="CL_R"/>
            <enum name="CL_A"/>
            <enum name="CL_RG"/>
            <enum name="CL_RA"/>
            <enum name="CL_RGB"/>
            <enum name="CL_RGBA"/>
            <enum name="CL_BGRA"/>
            <enum name="CL_ARGB"/>
            <enum name="CL_INTENSITY"/>
            <enum name="CL_LUMINANCE"/>
        </require>
        <require comment="cl_channel_type">
            <enum name="CL_SNORM_INT8"/>
            <enum name="CL_SNORM_INT16"/>
            <enum name="CL_UNORM_INT8"/>
            <enum name="CL_UNORM_INT16"/>
            <enum name="CL_UNORM_SHORT_565"/>
            <enum name="CL_UNORM_SHORT_555"/>
            <enum name="CL_UNORM_INT_101010"/>
            <enum name="CL_SIGNED_INT8"/>
            <enum name="CL_SIGNED_INT16"/>
            <enum name="CL_SIGNED_INT32"/>
            <enum name="CL_UNSIGNED_INT8"/>
            <enum name="CL_UNSIGNED_INT16"/>
            <enum name="CL_UNSIGNED_INT32"/>
            <enum name="CL_HALF_FLOAT"/>
            <enum name="CL_FLOAT"/>
        </require>
        <require comment="cl_mem_object_type">
            <enum name="CL_MEM_OBJECT_BUFFER"/>
            <enum name="CL_MEM_OBJECT_IMAGE2D"/>
            <enum name="CL_MEM_OBJECT_IMAGE3D"/>
        </require>
        <require comment="cl_mem_info">
            <enum name="CL_MEM_TYPE" return_type="cl_mem_object_type"/>
            <enum name="CL_MEM_FLAGS" return_type="cl_mem_flags"/>
            <enum name="CL_MEM_SIZE" return_type="size_t"/>
            <enum name="CL_MEM_HOST_PTR" return_type="void*"/>
            <enum name="CL_MEM_MAP_COUNT" return_type="cl_uint"/>
            <enum name="CL_MEM_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_MEM_CONTEXT" return_type="cl_context"/>
        </require>
        <require comment="cl_image_info">
            <enum name="CL_IMAGE_FORMAT" return_type="cl_image_format"/>
            <enum name="CL_IMAGE_ELEMENT_SIZE" return_type="size_t"/>
            <enum name="CL_IMAGE_ROW_PITCH" return_type="size_t"/>
            <enum name="CL_IMAGE_SLICE_PITCH" return_type="size_t"/>
            <enum name="CL_IMAGE_WIDTH" return_type="size_t"/>
            <enum name="CL_IMAGE_HEIGHT" return_type="size_t"/>
            <enum name="CL_IMAGE_DEPTH" return_type="size_t"/>
        </require>
        <require comment="cl_addressing_mode">
            <enum name="CL_ADDRESS_NONE"/>
            <enum name="CL_ADDRESS_CLAMP_TO_EDGE"/>
            <enum name="CL_ADDRESS_CLAMP"/>
            <enum name="CL_ADDRESS_REPEAT"/>
        </require>
        <require comment="cl_filter_mode">
            <enum name="CL_FILTER_NEAREST"/>
            <enum name="CL_FILTER_LINEAR"/>
        </require>
        <require comment="cl_sampler_info">
            <enum name="CL_SAMPLER_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_SAMPLER_CONTEXT" return_type="cl_context"/>
            <enum name="CL_SAMPLER_NORMALIZED_COORDS" return_type="cl_bool"/>
            <enum name="CL_SAMPLER_ADDRESSING_MODE" return_type="cl_addressing_mode"/>
            <enum name="CL_SAMPLER_FILTER_MODE" return_type="cl_filter_mode"/>
        </require>
        <require comment="cl_map_flags - bitfield">
            <enum name="CL_MAP_READ"/>
            <enum name="CL_MAP_WRITE"/>
        </require>
        <require comment="cl_program_info">
            <enum name="CL_PROGRAM_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_PROGRAM_CONTEXT" return_type="cl_context"/>
            <enum name="CL_PROGRAM_NUM_DEVICES" return_type="cl_uint"/>
            <enum name="CL_PROGRAM_DEVICES" return_type="cl_device_id[]"/>
            <enum name="CL_PROGRAM_SOURCE" return_type="char[]"/>
            <enum name="CL_PROGRAM_BINARY_SIZES" return_type="size_t[]"/>
            <enum name="CL_PROGRAM_BINARIES" return_type="unsigned char*[]"/>
        </require>
        <require comment="cl_program_build_info">
            <enum name="CL_PROGRAM_BUILD_STATUS" return_type="cl_build_status"/>
            <enum name="CL_PROGRAM_BUILD_OPTIONS" return_type="char[]"/>
            <enum name="CL_PROGRAM_BUILD_LOG" return_type="char[]"/>
        </require>
        <require comment="cl_build_status">
            <enum name="CL_BUILD_SUCCESS"/>
            <enum name="CL_BUILD_NONE"/>
            <enum name="CL_BUILD_ERROR"/>
            <enum name="CL_BUILD_IN_PROGRESS"/>
        </require>
        <require comment="cl_kernel_info">
            <enum name="CL_KERNEL_FUNCTION_NAME" return_type="char[]"/>
            <enum name="CL_KERNEL_NUM_ARGS" return_type="cl_uint"/>
            <enum name="CL_KERNEL_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_KERNEL_CONTEXT" return_type="cl_context"/>
            <enum name="CL_KERNEL_PROGRAM" return_type="cl_program"/>
        </require>
        <require comment="cl_kernel_work_group_info">
            <enum name="CL_KERNEL_WORK_GROUP_SIZE" return_type="size_t"/>
            <enum name="CL_KERNEL_COMPILE_WORK_GROUP_SIZE" return_type="size_t[3]"/>
            <enum name="CL_KERNEL_LOCAL_MEM_SIZE" return_type="cl_ulong"/>
            <enum name="CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE" return_type="size_t"/>
            <enum name="CL_KERNEL_PRIVATE_MEM_SIZE" return_type="cl_ulong"/>
        </require>
        <require comment="cl_event_info">
            <enum name="CL_EVENT_COMMAND_QUEUE" return_type="cl_command_queue"/>
            <enum name="CL_EVENT_COMMAND_TYPE" return_type="cl_command_type"/>
            <enum name="CL_EVENT_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_EVENT_COMMAND_EXECUTION_STATUS" return_type="cl_int"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_NDRANGE_KERNEL"/>
            <enum name="CL_COMMAND_TASK"/>
            <enum name="CL_COMMAND_NATIVE_KERNEL"/>
            <enum name="CL_COMMAND_READ_BUFFER"/>
            <enum name="CL_COMMAND_WRITE_BUFFER"/>
            <enum name="CL_COMMAND_COPY_BUFFER"/>
            <enum name="CL_COMMAND_READ_IMAGE"/>
            <enum name="CL_COMMAND_WRITE_IMAGE"/>
            <enum name="CL_COMMAND_COPY_IMAGE"/>
            <enum name="CL_COMMAND_COPY_IMAGE_TO_BUFFER"/>
            <enum name="CL_COMMAND_COPY_BUFFER_TO_IMAGE"/>
            <enum name="CL_COMMAND_MAP_BUFFER"/>
            <enum name="CL_COMMAND_MAP_IMAGE"/>
            <enum name="CL_COMMAND_UNMAP_MEM_OBJECT"/>
            <enum name="CL_COMMAND_MARKER"/>
            <enum name="CL_COMMAND_ACQUIRE_GL_OBJECTS"/>
            <enum name="CL_COMMAND_RELEASE_GL_OBJECTS"/>
        </require>
        <require comment="command execution status">
            <enum name="CL_COMPLETE"/>
            <enum name="CL_RUNNING"/>
            <enum name="CL_SUBMITTED"/>
            <enum name="CL_QUEUED"/>
        </require>
        <require comment="cl_khronos_vendor_id">
            <!-- The cl_khronos_vendor_id type was added in OpenCL 3.0, but the
                 concept of assigned vendor IDs has existed since OpenCL 1.0.
                 These enums can be used in any OpenCL version because the type
                 used in the API is cl_uint. -->
            <enum name="CL_KHRONOS_VENDOR_ID_CODEPLAY"/>
            <enum name="CL_KHRONOS_VENDOR_ID_POCL"/>
        </require>
        <require comment="Platform APIs">
            <command name="clGetPlatformIDs"/>
            <command name="clGetPlatformInfo"/>
        </require>
        <require comment="Device APIs">
            <command name="clGetDeviceIDs"/>
            <command name="clGetDeviceInfo"/>
        </require>
        <require comment="Context APIs">
            <command name="clCreateContext"/>
            <command name="clCreateContextFromType"/>
            <command name="clRetainContext"/>
            <command name="clReleaseContext"/>
            <command name="clGetContextInfo"/>
        </require>
        <require comment="Command Queue APIs">
            <command name="clRetainCommandQueue"/>
            <command name="clReleaseCommandQueue"/>
            <command name="clGetCommandQueueInfo"/>
        </require>
        <require comment="Memory Object APIs">
            <command name="clCreateBuffer"/>
            <command name="clRetainMemObject"/>
            <command name="clReleaseMemObject"/>
            <command name="clGetSupportedImageFormats"/>
            <command name="clGetMemObjectInfo"/>
            <command name="clGetImageInfo"/>
        </require>
        <require comment="Sampler APIs">
            <command name="clRetainSampler"/>
            <command name="clReleaseSampler"/>
            <command name="clGetSamplerInfo"/>
        </require>
        <require comment="Program Object APIs">
            <command name="clCreateProgramWithSource"/>
            <command name="clCreateProgramWithBinary"/>
            <command name="clRetainProgram"/>
            <command name="clReleaseProgram"/>
            <command name="clBuildProgram"/>
            <command name="clGetProgramInfo"/>
            <command name="clGetProgramBuildInfo"/>
        </require>
        <require comment="Kernel Object APIs">
            <command name="clCreateKernel"/>
            <command name="clCreateKernelsInProgram"/>
            <command name="clRetainKernel"/>
            <command name="clReleaseKernel"/>
            <command name="clSetKernelArg"/>
            <command name="clGetKernelInfo"/>
            <command name="clGetKernelWorkGroupInfo"/>
        </require>
        <require comment="Event Object APIs">
            <command name="clWaitForEvents"/>
            <command name="clGetEventInfo"/>
            <command name="clRetainEvent"/>
            <command name="clReleaseEvent"/>
        </require>
        <require comment="Profiling APIs">
            <command name="clGetEventProfilingInfo"/>
        </require>
        <require comment="Flush and Finish APIs">
            <command name="clFlush"/>
            <command name="clFinish"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueReadBuffer"/>
            <command name="clEnqueueWriteBuffer"/>
            <command name="clEnqueueCopyBuffer"/>
            <command name="clEnqueueReadImage"/>
            <command name="clEnqueueWriteImage"/>
            <command name="clEnqueueCopyImage"/>
            <command name="clEnqueueCopyImageToBuffer"/>
            <command name="clEnqueueCopyBufferToImage"/>
            <command name="clEnqueueMapBuffer"/>
            <command name="clEnqueueMapImage"/>
            <command name="clEnqueueUnmapMemObject"/>
            <command name="clEnqueueNDRangeKernel"/>
            <command name="clEnqueueNativeKernel"/>
        </require>
        <require comment="OpenCL 1.0 APIs that were deprecated in OpenCL 1.1">
            <comment>
            #ifdef CL_USE_DEPRECATED_OPENCL_1_0_APIS
                /*
                 *  WARNING:
                 *     This API introduces mutable state into the OpenCL implementation. It has been REMOVED
                 *  to better facilitate thread safety.  The 1.0 API is not thread safe. It is not tested by the
                 *  OpenCL 1.1 conformance test, and consequently may not work or may not work dependably.
                 *  It is likely to be non-performant. Use of this API is not advised. Use at your own risk.
                 *
                 *  Software developers previously relying on this API are instructed to set the command queue
                 *  properties when creating the queue, instead.
                 */
            #endif /* CL_USE_DEPRECATED_OPENCL_1_0_APIS */
            </comment>
            <command name="clSetCommandQueueProperty"/>
        </require>
        <require comment="OpenCL 1.0 APIs that were deprecated in OpenCL 1.2">
            <command name="clCreateImage2D"/>
            <command name="clCreateImage3D"/>
            <command name="clEnqueueMarker"/>
            <command name="clEnqueueWaitForEvents"/>
            <command name="clEnqueueBarrier"/>
            <command name="clUnloadCompiler"/>
            <command name="clGetExtensionFunctionAddress"/>
        </require>
        <require comment="OpenCL 1.0 cl_device_info enums that were deprecated in OpenCL 1.2">
            <enum name="CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE" return_type="cl_uint"/>
        </require>
        <require comment="OpenCL 1.0 APIs that were deprecated in OpenCL 2.0">
            <command name="clCreateCommandQueue"/>
            <command name="clCreateSampler"/>
            <command name="clEnqueueTask"/>
        </require>
        <require comment="OpenCL 1.0 cl_device_info enums that were deprecated in OpenCL 2.0">
            <enum name="CL_DEVICE_QUEUE_PROPERTIES" return_type="cl_command_queue_properties"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_1_1" number="1.1" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_buffer_create_type"/>
        </require>
        <require comment="Constants">
            <enum name="CL_NAN"/>
            <enum name="CL_HUGE_VALF"/>
            <enum name="CL_HUGE_VAL"/>
            <enum name="CL_MAXFLOAT"/>
            <enum name="CL_INFINITY"/>
        </require>
        <require comment="Error codes">
            <enum name="CL_MISALIGNED_SUB_BUFFER_OFFSET"/>
            <enum name="CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST"/>
            <enum name="CL_INVALID_PROPERTY"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_INT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF" return_type="cl_uint"/>
        </require>
        <require comment="cl_device_fp_config - bitfield">
            <enum name="CL_FP_SOFT_FLOAT"/>
        </require>
        <require comment="cl_context_info">
            <enum name="CL_CONTEXT_NUM_DEVICES" return_type="cl_uint"/>
        </require>
        <require comment="cl_channel_order">
            <enum name="CL_Rx"/>
            <enum name="CL_RGx"/>
            <enum name="CL_RGBx"/>
        </require>
        <require comment="cl_mem_info">
            <enum name="CL_MEM_ASSOCIATED_MEMOBJECT" return_type="cl_mem"/>
            <enum name="CL_MEM_OFFSET" return_type="size_t"/>
        </require>
        <require comment="cl_addressing_mode">
            <enum name="CL_ADDRESS_MIRRORED_REPEAT"/>
        </require>
        <require comment="cl_event_info">
            <enum name="CL_EVENT_CONTEXT" return_type="cl_context"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_READ_BUFFER_RECT"/>
            <enum name="CL_COMMAND_WRITE_BUFFER_RECT"/>
            <enum name="CL_COMMAND_COPY_BUFFER_RECT"/>
            <enum name="CL_COMMAND_USER"/>
        </require>
        <require comment="cl_buffer_create_type">
            <enum name="CL_BUFFER_CREATE_TYPE_REGION"/>
        </require>
        <require comment="Memory Object APIs">
            <command name="clCreateSubBuffer"/>
            <command name="clSetMemObjectDestructorCallback"/>
        </require>
        <require comment="Event Object APIs">
            <command name="clCreateUserEvent"/>
            <command name="clSetUserEventStatus"/>
            <command name="clSetEventCallback"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueReadBufferRect"/>
            <command name="clEnqueueWriteBufferRect"/>
            <command name="clEnqueueCopyBufferRect"/>
        </require>
        <require comment="OpenCL 1.1 cl_device_info enums that were deprecated in OpenCL 2.0">
            <enum name="CL_DEVICE_HOST_UNIFIED_MEMORY" return_type="cl_bool"/>
        </require>
        <require comment="OpenCL 1.1 cl_device_info enums that were deprecated in OpenCL 3.0">
            <enum name="CL_DEVICE_OPENCL_C_VERSION" return_type="char[]"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_1_2" number="1.2" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_device_partition_property"/>
            <type name="cl_device_affinity_domain"/>
            <type name="cl_mem_migration_flags"/>
            <type name="cl_program_binary_type"/>
            <type name="cl_kernel_arg_info"/>
            <type name="cl_kernel_arg_address_qualifier"/>
            <type name="cl_kernel_arg_access_qualifier"/>
            <type name="cl_kernel_arg_type_qualifier"/>
            <type name="cl_image_desc"/>
        </require>
        <require comment="Constants">
            <enum name="CL_DBL_DIG"/>
            <enum name="CL_DBL_MANT_DIG"/>
            <enum name="CL_DBL_MAX_10_EXP"/>
            <enum name="CL_DBL_MAX_EXP"/>
            <enum name="CL_DBL_MIN_10_EXP"/>
            <enum name="CL_DBL_MIN_EXP"/>
            <enum name="CL_DBL_RADIX"/>
            <enum name="CL_DBL_MAX"/>
            <enum name="CL_DBL_MIN"/>
            <enum name="CL_DBL_EPSILON"/>
        </require>
        <require comment="Error codes">
            <enum name="CL_COMPILE_PROGRAM_FAILURE"/>
            <enum name="CL_LINKER_NOT_AVAILABLE"/>
            <enum name="CL_LINK_PROGRAM_FAILURE"/>
            <enum name="CL_DEVICE_PARTITION_FAILED"/>
            <enum name="CL_KERNEL_ARG_INFO_NOT_AVAILABLE"/>
            <enum name="CL_INVALID_IMAGE_DESCRIPTOR"/>
            <enum name="CL_INVALID_COMPILER_OPTIONS"/>
            <enum name="CL_INVALID_LINKER_OPTIONS"/>
            <enum name="CL_INVALID_DEVICE_PARTITION_COUNT"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_BARRIER"/>
            <enum name="CL_COMMAND_MIGRATE_MEM_OBJECTS"/>
            <enum name="CL_COMMAND_FILL_BUFFER"/>
            <enum name="CL_COMMAND_FILL_IMAGE"/>
        </require>
        <require comment="cl_bool">
            <enum name="CL_BLOCKING"/>
            <enum name="CL_NON_BLOCKING"/>
        </require>
        <require comment="cl_device_type - bitfield">
            <enum name="CL_DEVICE_TYPE_CUSTOM"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_DOUBLE_FP_CONFIG" return_type="cl_device_fp_config"/>
            <enum name="CL_DEVICE_LINKER_AVAILABLE" return_type="cl_bool"/>
            <enum name="CL_DEVICE_BUILT_IN_KERNELS" return_type="char[]"/>
            <enum name="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_PARENT_DEVICE" return_type="cl_device_id"/>
            <enum name="CL_DEVICE_PARTITION_MAX_SUB_DEVICES" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PARTITION_PROPERTIES" return_type="cl_device_partition_property[]"/>
            <enum name="CL_DEVICE_PARTITION_AFFINITY_DOMAIN" return_type="cl_device_affinity_domain"/>
            <enum name="CL_DEVICE_PARTITION_TYPE" return_type="cl_device_partition_property[]"/>
            <enum name="CL_DEVICE_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_INTEROP_USER_SYNC" return_type="cl_bool"/>
            <enum name="CL_DEVICE_PRINTF_BUFFER_SIZE" return_type="size_t"/>
        </require>
        <require comment="cl_device_fp_config - bitfield">
            <enum name="CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT"/>
        </require>
        <require comment="cl_context_properties">
            <enum name="CL_CONTEXT_INTEROP_USER_SYNC"/>
        </require>
        <require comment="cl_device_partition_property">
            <enum name="CL_DEVICE_PARTITION_EQUALLY"/>
            <enum name="CL_DEVICE_PARTITION_BY_COUNTS"/>
            <enum name="CL_DEVICE_PARTITION_BY_COUNTS_LIST_END"/>
            <enum name="CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN"/>
        </require>
        <require comment="cl_device_affinity_domain">
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_NUMA"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE"/>
        </require>
        <require comment="cl_mem_flags and cl_svm_mem_flags - bitfield">
            <enum name="CL_MEM_HOST_WRITE_ONLY"/>
            <enum name="CL_MEM_HOST_READ_ONLY"/>
            <enum name="CL_MEM_HOST_NO_ACCESS"/>
        </require>
        <require comment="cl_mem_migration_flags - bitfield">
            <enum name="CL_MIGRATE_MEM_OBJECT_HOST"/>
            <enum name="CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED"/>
        </require>
        <require comment="cl_mem_object_type">
            <enum name="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
            <enum name="CL_MEM_OBJECT_IMAGE1D"/>
            <enum name="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
            <enum name="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
        </require>
        <require comment="cl_image_info">
            <enum name="CL_IMAGE_ARRAY_SIZE" return_type="size_t"/>
            <enum name="CL_IMAGE_NUM_MIP_LEVELS" return_type="cl_uint"/>
            <enum name="CL_IMAGE_NUM_SAMPLES" return_type="cl_uint"/>
        </require>
        <require comment="cl_map_flags - bitfield">
            <enum name="CL_MAP_WRITE_INVALIDATE_REGION"/>
        </require>
        <require comment="cl_program_info">
            <enum name="CL_PROGRAM_NUM_KERNELS" return_type="size_t"/>
            <enum name="CL_PROGRAM_KERNEL_NAMES" return_type="char[]"/>
        </require>
        <require comment="cl_program_build_info">
            <enum name="CL_PROGRAM_BINARY_TYPE" return_type="cl_program_binary_type"/>
        </require>
        <require comment="cl_program_binary_type">
            <enum name="CL_PROGRAM_BINARY_TYPE_NONE"/>
            <enum name="CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT"/>
            <enum name="CL_PROGRAM_BINARY_TYPE_LIBRARY"/>
            <enum name="CL_PROGRAM_BINARY_TYPE_EXECUTABLE"/>
        </require>
        <require comment="cl_kernel_info">
            <enum name="CL_KERNEL_ATTRIBUTES" return_type="char[]"/>
        </require>
        <require comment="cl_kernel_arg_info">
            <enum name="CL_KERNEL_ARG_ADDRESS_QUALIFIER" return_type="cl_kernel_arg_address_qualifier"/>
            <enum name="CL_KERNEL_ARG_ACCESS_QUALIFIER" return_type="cl_kernel_arg_access_qualifier"/>
            <enum name="CL_KERNEL_ARG_TYPE_NAME" return_type="char[]"/>
            <enum name="CL_KERNEL_ARG_TYPE_QUALIFIER" return_type="cl_kernel_arg_type_qualifier"/>
            <enum name="CL_KERNEL_ARG_NAME" return_type="char[]"/>
        </require>
        <require comment="cl_kernel_arg_address_qualifier">
            <enum name="CL_KERNEL_ARG_ADDRESS_GLOBAL"/>
            <enum name="CL_KERNEL_ARG_ADDRESS_LOCAL"/>
            <enum name="CL_KERNEL_ARG_ADDRESS_CONSTANT"/>
            <enum name="CL_KERNEL_ARG_ADDRESS_PRIVATE"/>
        </require>
        <require comment="cl_kernel_arg_access_qualifier">
            <enum name="CL_KERNEL_ARG_ACCESS_READ_ONLY"/>
            <enum name="CL_KERNEL_ARG_ACCESS_WRITE_ONLY"/>
            <enum name="CL_KERNEL_ARG_ACCESS_READ_WRITE"/>
            <enum name="CL_KERNEL_ARG_ACCESS_NONE"/>
        </require>
        <require comment="cl_kernel_arg_type_qualifier">
            <enum name="CL_KERNEL_ARG_TYPE_NONE"/>
            <enum name="CL_KERNEL_ARG_TYPE_CONST"/>
            <enum name="CL_KERNEL_ARG_TYPE_RESTRICT"/>
            <enum name="CL_KERNEL_ARG_TYPE_VOLATILE"/>
        </require>
        <require comment="cl_kernel_work_group_info">
            <enum name="CL_KERNEL_GLOBAL_WORK_SIZE" return_type="size_t[3]"/>
        </require>
        <require comment="Platform APIs">
            <command name="clCreateSubDevices"/>
            <command name="clRetainDevice"/>
            <command name="clReleaseDevice"/>
        </require>
        <require comment="Memory Object APIs">
            <command name="clCreateImage"/>
        </require>
        <require comment="Program Object APIs">
            <command name="clCreateProgramWithBuiltInKernels"/>
            <command name="clCompileProgram"/>
            <command name="clLinkProgram"/>
            <command name="clUnloadPlatformCompiler"/>
        </require>
        <require comment="Kernel Object APIs">
            <command name="clGetKernelArgInfo"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueFillBuffer"/>
            <command name="clEnqueueFillImage"/>
            <command name="clEnqueueMigrateMemObjects"/>
            <command name="clEnqueueMarkerWithWaitList"/>
            <command name="clEnqueueBarrierWithWaitList"/>
        </require>
        <require comment="Extension function access">
            <command name="clGetExtensionFunctionAddressForPlatform"/>
        </require>
        <require comment="OpenCL 1.2 cl_image_info enums that were deprecated in OpenCL 2.0">
            <enum name="CL_IMAGE_BUFFER" return_type="cl_mem"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_2_0" number="2.0" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_device_svm_capabilities"/>
            <type name="cl_queue_properties"/>
            <type name="cl_svm_mem_flags"/>
            <type name="cl_pipe_properties"/>
            <type name="cl_pipe_info"/>
            <type name="cl_sampler_properties"/>
            <type name="cl_kernel_exec_info"/>
        </require>
        <require comment="Error codes">
            <enum name="CL_INVALID_PIPE_SIZE"/>
            <enum name="CL_INVALID_DEVICE_QUEUE"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_QUEUE_ON_HOST_PROPERTIES" return_type="cl_command_queue_properties"/>
            <enum name="CL_DEVICE_IMAGE_PITCH_ALIGNMENT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_READ_WRITE_IMAGE_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_GLOBAL_VARIABLE_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES" return_type="cl_command_queue_properties"/>
            <enum name="CL_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_ON_DEVICE_QUEUES" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_ON_DEVICE_EVENTS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_SVM_CAPABILITIES" return_type="cl_device_svm_capabilities"/>
            <enum name="CL_DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_MAX_PIPE_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PIPE_MAX_PACKET_SIZE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT" return_type="cl_uint"/>
        </require>
        <require comment="cl_command_queue_properties - bitfield">
            <enum name="CL_QUEUE_ON_DEVICE"/>
            <enum name="CL_QUEUE_ON_DEVICE_DEFAULT"/>
        </require>
        <require comment="cl_device_svm_capabilities">
            <enum name="CL_DEVICE_SVM_COARSE_GRAIN_BUFFER"/>
            <enum name="CL_DEVICE_SVM_FINE_GRAIN_BUFFER"/>
            <enum name="CL_DEVICE_SVM_FINE_GRAIN_SYSTEM"/>
            <enum name="CL_DEVICE_SVM_ATOMICS"/>
        </require>
        <require comment="cl_command_queue_info">
            <enum name="CL_QUEUE_SIZE" return_type="cl_uint"/>
        </require>
        <require comment="cl_mem_flags and cl_svm_mem_flags - bitfield">
            <enum name="CL_MEM_SVM_FINE_GRAIN_BUFFER"/>
            <enum name="CL_MEM_SVM_ATOMICS"/>
            <enum name="CL_MEM_KERNEL_READ_AND_WRITE"/>
        </require>
        <require comment="cl_channel_order">
            <enum name="CL_DEPTH"/>
            <enum name="CL_sRGB"/>
            <enum name="CL_sRGBx"/>
            <enum name="CL_sRGBA"/>
            <enum name="CL_sBGRA"/>
            <enum name="CL_ABGR"/>
        </require>
        <require comment="cl_mem_object_type">
            <enum name="CL_MEM_OBJECT_PIPE"/>
        </require>
        <require comment="cl_mem_info">
            <enum name="CL_MEM_USES_SVM_POINTER" return_type="cl_bool"/>
        </require>
        <require comment="cl_pipe_info">
            <enum name="CL_PIPE_PACKET_SIZE" return_type="cl_uint"/>
            <enum name="CL_PIPE_MAX_PACKETS" return_type="cl_uint"/>
        </require>
        <!--<require comment="cl_sampler_info">
            <enum name="CL_SAMPLER_MIP_FILTER_MODE"/>
            <enum name="CL_SAMPLER_LOD_MIN"/>
            <enum name="CL_SAMPLER_LOD_MAX"/>
        </require>-->
        <require comment="cl_program_build_info">
            <enum name="CL_PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE" return_type="size_t"/>
        </require>
        <require comment="cl_kernel_arg_type_qualifier">
            <enum name="CL_KERNEL_ARG_TYPE_PIPE"/>
        </require>
        <require comment="cl_kernel_exec_info">
            <enum name="CL_KERNEL_EXEC_INFO_SVM_PTRS" return_type="void*[]"/>
            <enum name="CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM" return_type="cl_bool"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_SVM_FREE"/>
            <enum name="CL_COMMAND_SVM_MEMCPY"/>
            <enum name="CL_COMMAND_SVM_MEMFILL"/>
            <enum name="CL_COMMAND_SVM_MAP"/>
            <enum name="CL_COMMAND_SVM_UNMAP"/>
        </require>
        <require comment="cl_profiling_info">
            <enum name="CL_PROFILING_COMMAND_COMPLETE" return_type="cl_ulong"/>
        </require>
        <require comment="Command Queue APIs">
            <command name="clCreateCommandQueueWithProperties"/>
        </require>
        <require comment="Pipe APIs">
            <command name="clCreatePipe"/>
            <command name="clGetPipeInfo"/>
        </require>
        <require comment="SVM Allocation APIs">
            <command name="clSVMAlloc"/>
            <command name="clSVMFree"/>
        </require>
        <require comment="Sampler APIs">
            <command name="clCreateSamplerWithProperties"/>
        </require>
        <require comment="Kernel Object APIs">
            <command name="clSetKernelArgSVMPointer"/>
            <command name="clSetKernelExecInfo"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueSVMFree"/>
            <command name="clEnqueueSVMMemcpy"/>
            <command name="clEnqueueSVMMemFill"/>
            <command name="clEnqueueSVMMap"/>
            <command name="clEnqueueSVMUnmap"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_2_1" number="2.1" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_kernel_sub_group_info"/>
        </require>
        <require comment="cl_platform_info">
            <enum name="CL_PLATFORM_HOST_TIMER_RESOLUTION" return_type="cl_ulong"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_IL_VERSION" return_type="char[]"/>
            <enum name="CL_DEVICE_MAX_NUM_SUB_GROUPS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS" return_type="cl_bool"/>
        </require>
        <require comment="cl_command_queue_info">
            <enum name="CL_QUEUE_DEVICE_DEFAULT" return_type="cl_command_queue"/>
        </require>
        <require comment="cl_channel_type">
            <enum name="CL_UNORM_INT_101010_2"/>
        </require>
        <require comment="cl_program_info">
            <enum name="CL_PROGRAM_IL" return_type="char[]"/>
        </require>
        <require comment="cl_kernel_sub_group_info">
            <enum name="CL_KERNEL_MAX_NUM_SUB_GROUPS" return_type="size_t"/>
            <enum name="CL_KERNEL_COMPILE_NUM_SUB_GROUPS" return_type="size_t"/>
            <enum name="CL_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE" return_type="size_t"/>
            <enum name="CL_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE" return_type="size_t"/>
            <enum name="CL_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT" return_type="size_t[]"/>
        </require>
        <require comment="Platform APIs">
            <command name="clSetDefaultDeviceCommandQueue"/>
        </require>
        <require comment="Device APIs">
            <command name="clGetDeviceAndHostTimer"/>
            <command name="clGetHostTimer"/>
        </require>
        <require comment="Program Object APIs">
            <command name="clCreateProgramWithIL"/>
        </require>
        <require comment="Kernel Object APIs">
            <command name="clCloneKernel"/>
            <command name="clGetKernelSubGroupInfo"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueSVMMigrateMem"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_2_2" number="2.2" comment="OpenCL core API interface definitions">
        <require comment="Error codes">
            <enum name="CL_INVALID_SPEC_ID"/>
            <enum name="CL_MAX_SIZE_RESTRICTION_EXCEEDED"/>
        </require>
        <require comment="Program Object APIs">
            <command name="clSetProgramSpecializationConstant"/>
        </require>
        <require comment="OpenCL 2.2 Program Object APIs that were deprecated in OpenCL 3.0">
            <command name="clSetProgramReleaseCallback"/>
        </require>
        <require comment="OpenCL 2.2 cl_program_info enums that were deprecated in OpenCL 3.0">
            <enum name="CL_PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT" return_type="cl_bool"/>
            <enum name="CL_PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT" return_type="cl_bool"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_3_0" number="3.0" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_device_atomic_capabilities"/>
            <type name="cl_device_device_enqueue_capabilities"/>
            <type name="cl_khronos_vendor_id"/>
            <type name="cl_mem_properties"/>
            <type name="cl_version"/>
            <type name="cl_name_version"/>
        </require>
        <require comment="cl_device_atomic_capabilities - bitfield">
            <enum name="CL_DEVICE_ATOMIC_ORDER_RELAXED"/>
            <enum name="CL_DEVICE_ATOMIC_ORDER_ACQ_REL"/>
            <enum name="CL_DEVICE_ATOMIC_ORDER_SEQ_CST"/>
            <enum name="CL_DEVICE_ATOMIC_SCOPE_WORK_ITEM"/>
            <enum name="CL_DEVICE_ATOMIC_SCOPE_WORK_GROUP"/>
            <enum name="CL_DEVICE_ATOMIC_SCOPE_DEVICE"/>
            <enum name="CL_DEVICE_ATOMIC_SCOPE_ALL_DEVICES"/>
        </require>
        <require comment="cl_device_device_enqueue_capabilities - bitfield">
            <enum name="CL_DEVICE_QUEUE_SUPPORTED"/>
            <enum name="CL_DEVICE_QUEUE_REPLACEABLE_DEFAULT"/>
        </require>
        <require comment="cl_platform_info">
            <enum name="CL_PLATFORM_NUMERIC_VERSION" return_type="cl_version"/>
            <enum name="CL_PLATFORM_EXTENSIONS_WITH_VERSION" return_type="cl_name_version[]"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_ATOMIC_MEMORY_CAPABILITIES" return_type="cl_device_atomic_capabilities"/>
            <enum name="CL_DEVICE_ATOMIC_FENCE_CAPABILITIES" return_type="cl_device_atomic_capabilities"/>
            <enum name="CL_DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_OPENCL_C_ALL_VERSIONS" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_OPENCL_C_FEATURES" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_DEVICE_ENQUEUE_CAPABILITIES" return_type="cl_device_device_enqueue_capabilities"/>
            <enum name="CL_DEVICE_PIPE_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_NUMERIC_VERSION" return_type="cl_version"/>
            <enum name="CL_DEVICE_EXTENSIONS_WITH_VERSION" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_ILS_WITH_VERSION" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_BUILT_IN_KERNELS_WITH_VERSION" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE" return_type="size_t"/>
            <enum name="CL_DEVICE_LATEST_CONFORMANCE_VERSION_PASSED" return_type="char[]"/>
        </require>
        <require comment="cl_pipe_info">
            <enum name="CL_PIPE_PROPERTIES" return_type="cl_pipe_properties[]"/>
        </require>
        <require comment="cl_sampler_info">
            <enum name="CL_SAMPLER_PROPERTIES" return_type="cl_sampler_properties[]"/>
        </require>
        <require comment="cl_command_queue_info">
            <enum name="CL_QUEUE_PROPERTIES_ARRAY" return_type="cl_queue_properties[]"/>
        </require>
        <require comment="cl_mem_info">
            <enum name="CL_MEM_PROPERTIES" return_type="cl_mem_properties[]"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_SVM_MIGRATE_MEM"/>
        </require>
        <require comment="Misc API enums">
            <enum name="CL_VERSION_MAJOR_BITS"/>
            <enum name="CL_VERSION_MINOR_BITS"/>
            <enum name="CL_VERSION_PATCH_BITS"/>
            <enum name="CL_NAME_VERSION_MAX_NAME_SIZE"/>
        </require>
        <require comment="Context APIs">
            <command name="clSetContextDestructorCallback"/>
        </require>
        <require comment="Memory Object APIs">
            <command name="clCreateBufferWithProperties"/>
            <command name="clCreateImageWithProperties"/>
        </require>
    </feature>

    <!-- SECTION: CL command definitions. (TBD) -->
    <commands>
    <!-- 4.1 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetPlatformIDs</name></proto>
            <param><type>cl_uint</type>                                 <name>num_entries</name></param>
            <param><type>cl_platform_id</type>*                         <name>platforms</name></param>
            <param><type>cl_uint</type>*                                <name>num_platforms</name></param>

            <if>
                <or>
                    <and>
                        <eq>
                            <name>num_entries</name>                    <literal>0</literal>
                        </eq>
                        <neq>
                            <name>platforms</name>                      <literal>NULL</literal>
                        </neq>
                    </and>
                    <and>
                        <eq>
                            <name>num_platforms</name>                  <literal>NULL</literal>
                        </eq>
                        <eq>
                            <name>platforms</name>                      <literal>NULL</literal>
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clGetPlatformIDs</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>platforms</name>                          <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>platforms</name>                          <name>num_platforms[0]</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clGetPlatformIDs</name>                           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetPlatformInfo</name></proto>
            <param><type>cl_platform_id</type>                          <name>platform</name></param>
            <param><type>cl_platform_info</type>                        <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="platform"/>
            </if>
            <then>      <log>platform is not a valid platform</log>
                <name>clGetPlatformInfo</name>                          <value>CL_INVALID_PLATFORM</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetPlatformInfo</name>                          <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetPlatformInfo</name>                          <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetPlatformInfo</name>                          <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 4.2 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetDeviceIDs</name></proto>
            <param><type>cl_platform_id</type>                          <name>platform</name></param>
            <param><type>cl_device_type</type>                          <name>device_type</name></param>
            <param><type>cl_uint</type>                                 <name>num_entries</name></param>
            <param><type>cl_device_id</type>*                           <name>devices</name></param>
            <param><type>cl_uint</type>*                                <name>num_devices</name></param>

            <if>
                <object_is_invalid name="platform"/>
            </if>
            <then>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_PLATFORM</value>
            </then>
            <if>
                <or>
                    <bitfield_violation name="device_type"/>
                    <eq>
                        <name>device_type</name>                        <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_DEVICE_TYPE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>device_type</name>                        <literal>CL_DEVICE_TYPE_CUSTOM</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_CPU</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_GPU</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_ACCELERATOR</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_DEFAULT</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_DEVICE_TYPE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>num_entries</name>                    <literal>0</literal>
                        </eq>
                        <neq>
                            <name>devices</name>                        <literal>NULL</literal>
                        </neq>
                    </and>
                    <and>
                        <eq>
                            <name>num_devices</name>                    <literal>NULL</literal>
                        </eq>
                        <eq>
                            <name>devices</name>                        <literal>NULL</literal>
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>devices</name>                            <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>devices</name>                            <name>num_entries</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetDeviceInfo</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_device_info</type>                          <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>
                <name>clGetDeviceInfo</name>                            <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetDeviceInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetDeviceInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetDeviceInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1">
            <proto><type>cl_int</type>                                  <name>clGetDeviceAndHostTimer</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_ulong</type>*                               <name>device_timestamp</name></param>
            <param><type>cl_ulong</type>*                               <name>host_timestamp</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>
                <name>clGetDeviceAndHostTimer</name>                    <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>host_timestamp</name>                     <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>device_timestamp</name>                   <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clGetDeviceAndHostTimer</name>                    <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1">
            <proto><type>cl_int</type>                                  <name>clGetHostTimer</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_ulong</type>*                               <name>host_timestamp</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>
                <name>clGetHostTimer</name>                             <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <eq>
                    <name>host_timestamp</name>                         <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clGetHostTimer</name>                             <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 4.3 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clCreateSubDevices</name></proto>
            <param><type>cl_device_id</type>                            <name>in_device</name></param>
            <param>const <type>cl_device_partition_property</type>*     <name>properties</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param><type>cl_device_id</type>*                           <name>out_devices</name></param>
            <param><type>cl_uint</type>*                                <name>num_devices_ret</name></param>

            <if>
                <object_is_invalid name="in_device"/>
            </if>
            <then>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_DEVICE</value>
            </then>
            <!-- CL_INVALID_VALUE if values specified in properties are not valid or if values specified in properties are valid but not supported by the device. -->
            <if>
                <list_violation name="properties"/>
            </if>
            <then>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_DEVICE_PARTITION_COUNT if the partition name specified in properties is CL_DEVICE_PARTITION_BY_COUNTS and the number of sub-devices requested exceeds CL_DEVICE_PARTITION_MAX_SUB_DEVICES or the total number of compute units requested exceeds CL_DEVICE_MAX_COMPUTE_UNITS for in_device, or the number of compute units requested for one or more sub-devices is less than zero or the number of sub-devices requested exceeds CL_DEVICE_MAX_COMPUTE_UNITS for in_device. -->
            <if>
                <list_violation name="properties" param="in_device"/>
            </if>
            <then>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_DEVICE_PARTITION_COUNT</value>
            </then>
            <!-- CL_INVALID_VALUE if out_devices is not NULL and num_devices is less than the number of sub-devices created by the partition scheme. -->
            <if>
                <and>
                    <neq>
                        <name>out_devices</name>                        <literal>NULL</literal>
                    </neq>
                    <list_violation name="properties" param="in_device, num_devices"/>
                </and>
            </if>
            <then>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>out_devices</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>out_devices</name>                        <name>num_devices</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clRetainDevice</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>
                <name>clRetainDevice</name>                             <value>CL_INVALID_DEVICE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clReleaseDevice</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>
                <name>clReleaseDevice</name>                            <value>CL_INVALID_DEVICE</value>
            </then>
        </command>

    <!-- 4.4 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_context</type>                              <name>clCreateContext</name></proto>
            <param>const <type>cl_context_properties</type>*            <name>properties</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>devices</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(const char* errinfo, const void* private_info, size_t cb, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <!-- CL_INVALID_PROPERTY if context property name in properties is not a supported property name, if the value specified for a supported property name is not valid, or if the same property name is specified more than once. This error code is missing before version 1.1. -->
            <if>
                <and>
                    <from version="1.1"/>
                    <list_violation name="properties"/>
                </and>
            </if>
            <then>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROPERTY</value>
            </then>
            <!-- CL_INVALID_PLATFORM if properties is NULL and no platform could be selected or if platform value specified in properties is not a valid platform. -->
            <if>
                <list_violation name="properties" param="user_data"/>
            </if>
            <then>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PLATFORM</value>
            </then>
            <if>
                <eq>
                    <name>devices</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>num_devices</name>                            <literal>0</literal>
                </eq>
            </if>
            <then>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>devices</name>                            <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>devices</name>                            <name>num_devices</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_invalid array="devices" elements="num_devices"/>
            </if>
            <then>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <any_not_available array="devices" elements="num_devices"/>
            </if>
            <then>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_DEVICE_NOT_AVAILABLE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>pfn_notify</name>                         <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>user_data</name>                          <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_context</type>                              <name>clCreateContextFromType</name></proto>
            <param>const <type>cl_context_properties</type>*            <name>properties</name></param>
            <param><type>cl_device_type</type>                          <name>device_type</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(const char* errinfo, const void* private_info, size_t cb, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <!-- CL_INVALID_PROPERTY if context property name in properties is not a supported property name, if the value specified for a supported property name is not valid, or if the same property name is specified more than once. This error code is missing before version 1.1. -->
            <if>
                <and>
                    <from version="1.1"/>
                    <list_violation name="properties"/>
                </and>
            </if>
            <then>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROPERTY</value>
            </then>
            <!-- CL_INVALID_PLATFORM if properties is NULL and no platform could be selected or if platform value specified in properties is not a valid platform. -->
            <if>
                <list_violation name="properties" param="user_data"/>
            </if>
            <then>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PLATFORM</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>pfn_notify</name>                         <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>user_data</name>                          <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <bitfield_violation name="device_type"/>
                    <eq>
                        <name>device_type</name>                        <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE_TYPE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>device_type</name>                        <literal>CL_DEVICE_TYPE_CUSTOM</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_CPU</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_GPU</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_ACCELERATOR</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_DEFAULT</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE_TYPE</value>
            </then>
            <!--  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            CL_DEVICE_NOT_AVAILABLE if no devices that match device_type and property values specified in properties are currently available.
            CL_DEVICE_NOT_FOUND if no devices that match device_type and property values specified in properties were found. 
            -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clRetainContext</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clRetainContext</name>                            <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clReleaseContext</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clReleaseContext</name>                           <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetContextInfo</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_context_info</type>                         <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clGetContextInfo</name>                           <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetContextInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetContextInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetContextInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_3_0">
            <proto><type>cl_int</type>                                  <name>clSetContextDestructorCallback</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_context context, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clSetContextDestructorCallback</name>             <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>pfn_notify</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clSetContextDestructorCallback</name>             <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.1 -->

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_command_queue</type>                        <name>clCreateCommandQueueWithProperties</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param>const <type>cl_queue_properties</type>*              <name>properties</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateCommandQueueWithProperties</name>         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clCreateCommandQueueWithProperties</name>         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <object_not_in object="device" in="context"/>
            </if>
            <then>      <log>device is not associated with context</log>
                <name>clCreateCommandQueueWithProperties</name>         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <list_violation name="properties"/>
            </if>
            <then>      <log>values specified in properties are not valid</log>
                <name>clCreateCommandQueueWithProperties</name>         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_QUEUE_PROPERTIES if values specified in properties are valid but are not supported by the device. -->
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_2_DEPRECATED">
            <proto><type>cl_command_queue</type>                        <name>clCreateCommandQueue</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_command_queue_properties</type>             <name>properties</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clCreateCommandQueue</name>                       <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>
                <name>clCreateCommandQueue</name>                       <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <object_not_in object="device" in="context"/>
            </if>
            <then>
                <name>clCreateCommandQueue</name>                       <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <not>
                    <or>
                        <eq>
                            <name>properties</name>                         <literal>0</literal>
                        </eq>
                        <bit_and>
                            <name>properties</name>                         <literal>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</literal>
                        </bit_and>
                        <bit_and>
                            <name>properties</name>                         <literal>CL_QUEUE_PROFILING_ENABLE</literal>
                        </bit_and>
                    </or>
                </not>
            </if>
            <then>
                <name>clCreateCommandQueue</name>                       <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_QUEUE_PROPERTIES if values specified in properties are valid but are not supported by the device. -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1">
            <proto><type>cl_int</type>                                  <name>clSetDefaultDeviceCommandQueue</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <object_not_in object="device" in="context"/>
            </if>
            <then>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="device"/>
            </if>
            <then>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clRetainCommandQueue</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clRetainCommandQueue</name>                       <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clReleaseCommandQueue</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clReleaseCommandQueue</name>                      <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetCommandQueueInfo</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_command_queue_info</type>                   <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>param_name</name>                         <literal>CL_QUEUE_SIZE</literal>
                    </eq>
                    <not>
                        <bit_and>
                            <literal>CL_QUEUE_ON_DEVICE</literal>       <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                        </bit_and>
                    </not>
                </and>
            </if>
            <then>      <log>command_queue is not a valid command-queue for param_name</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not one of the supported values</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0_DEPRECATED">
            <proto><type>cl_int</type>                                  <name>clSetCommandQueueProperty</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_command_queue_properties</type>             <name>properties</name></param>
            <param><type>cl_bool</type>                                 <name>enable</name></param>
            <param><type>cl_command_queue_properties</type>*            <name>old_properties</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clSetCommandQueueProperty</name>                      <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <not>
                    <or>
                        <bit_and>
                            <name>properties</name>                         <literal>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</literal>
                        </bit_and>
                        <bit_and>
                            <name>properties</name>                         <literal>CL_QUEUE_PROFILING_ENABLE</literal>
                        </bit_and>
                    </or>
                </not>
            </if>
            <then>
                <name>clSetCommandQueueProperty</name>                  <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_QUEUE_PROPERTIES if values specified in properties are valid but are not supported by the device. -->
        </command>

    <!-- 5.2.1 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_mem</type>                                  <name>clCreateBuffer</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>


            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                </or>
            </if>
            <then>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>size</name>                                   <literal>0</literal>
                    <!-- or greater than CL_DEVICE_MAX_MEM_ALLOC_SIZE for all devices in context-->
                </eq>
            </if>
            <then>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_BUFFER_SIZE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </eq>
                        <or>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </or>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                        </not>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </not>
                    </and>
                </or>
            </if>
            <then>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>host_ptr</name>                           <name>size</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_3_0">
            <proto><type>cl_mem</type>                                  <name>clCreateBufferWithProperties</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>const <type>cl_mem_properties</type>*                <name>properties</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <list_violation name="properties"/>
            </if>
            <then>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROPERTY</value>
            </then>
            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                </or>
            </if>
            <then>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>size</name>                                   <literal>0</literal>
                    <!-- or greater than CL_DEVICE_MAX_MEM_ALLOC_SIZE for all devices in context-->
                </eq>
            </if>
            <then>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_BUFFER_SIZE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </eq>
                        <or>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </or>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                        </not>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </not>
                    </and>
                </or>
            </if>
            <then>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>host_ptr</name>                           <name>size</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1">
            <proto><type>cl_mem</type>                                  <name>clCreateSubBuffer</name></proto>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>cl_buffer_create_type</type>                   <name>buffer_create_type</name></param>
            <param>const <type>void</type>*                             <name>buffer_create_info</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <!-- CL_INVALID_VALUE if buffer was created with CL_MEM_WRITE_ONLY and flags specifies CL_MEM_READ_WRITE or CL_MEM_READ_ONLY, or if buffer was created with CL_MEM_READ_ONLY and flags specifies CL_MEM_READ_WRITE or CL_MEM_WRITE_ONLY, or if flags specifies CL_MEM_USE_HOST_PTR or CL_MEM_ALLOC_HOST_PTR or CL_MEM_COPY_HOST_PTR.-->
            <!-- CL_INVALID_VALUE if buffer was created with CL_MEM_HOST_WRITE_ONLY and flags specify CL_MEM_HOST_READ_ONLY, or if buffer was created with CL_MEM_HOST_READ_ONLY and flags specify CL_MEM_HOST_WRITE_ONLY, or if buffer was created with CL_MEM_HOST_NO_ACCESS and flags specify CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_WRITE_ONLY-->
            <if>
                <neq>
                    <name>buffer_create_type</name>                     <literal>CL_BUFFER_CREATE_TYPE_REGION</literal>
                </neq>
            </if>
            <then>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>buffer_create_info</name>                     <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>buffer_create_type</name>                 <literal>CL_BUFFER_CREATE_TYPE_REGION</literal>
                    </eq>
                    <array_len_ls>
                        <name>buffer_create_info</name>                 <sizeof>cl_buffer_region</sizeof>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if the region specified by the cl_buffer_region structure passed in buffer_create_info is out of bounds in buffer-->
            <!--<if>-->
            <!--    <and>-->
            <!--        <eq>-->
            <!--            <name>buffer_create_type</name>                 <literal>CL_BUFFER_CREATE_TYPE_REGION</literal>-->
            <!--        </eq>-->
            <!--        <eq>-->
            <!--            <name field="size">buffer_create_info</name>    <literal>0</literal> // type mismatch ???-->
            <!--        </eq>-->
            <!--    </and>-->
            <!--</if>-->
            <!--<then>-->
            <!--    <name>clCreateSubBuffer</name>                          <value>NULL</value>-->
            <!--    <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>-->
            <!--</then>-->
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if there are no devices in context associated with buffer for which the origin field of the cl_buffer_region structure passed in buffer_create_info is aligned to the CL_DEVICE_MEM_BASE_ADDR_ALIGN value-->
        </command>

    <!-- 5.2.2 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueReadBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_read</name></param>
            <param><type>size_t</type>                                  <name>offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>void</type>*                                   <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
                <!-- if the region being read or written specified by (offset, size) is out of bounds -->
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>ptr</name>                                    <name>size</name>
                </array_len_ls>
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_INVALID_OPERATION if clEnqueueReadBuffer is called on buffer which has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS.-->
            <!-- CL_INVALID_OPERATION if clEnqueueWriteBuffer is called on buffer which has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS.-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueWriteBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_write</name></param>
            <param><type>size_t</type>                                  <name>offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param>const <type>void</type>*                             <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>ptr</name>                                    <name>size</name>
                </array_len_ls>
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_INVALID_OPERATION if clEnqueueReadBuffer is called on buffer which has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS.-->
            <!-- CL_INVALID_OPERATION if clEnqueueWriteBuffer is called on buffer which has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS.-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1">
            <proto><type>cl_int</type>                                  <name>clEnqueueReadBufferRect</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_read</name></param>
            <param>const <type>size_t</type>*                           <name>buffer_origin</name></param>
            <param>const <type>size_t</type>*                           <name>host_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>buffer_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>buffer_slice_pitch</name></param>
            <param><type>size_t</type>                                  <name>host_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>host_slice_pitch</name></param>
            <param><type>void</type>*                                   <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>buffer_origin</name>                      <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>host_origin</name>                        <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if the region being read or written specified by (buffer_origin, region, buffer_row_pitch, buffer_slice_pitch) is out of bounds. -->
            <if>
                <or>
                    <array_len_ls>
                        <name>buffer_origin</name>                      <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>host_origin</name>                        <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then> <!-- not sure if this is right error-->
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </neq>
                    <ls>
                        <name>buffer_row_pitch</name>                   <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </neq>
                    <ls>
                        <name>host_row_pitch</name>                     <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </neq>
                    <neq>
                        <name>buffer_slice_pitch</name>                 <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>buffer_slice_pitch</name>             <mult>
                                                                            <name>region[1]</name>
                                                                            <name>buffer_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>buffer_slice_pitch</name>
                                <name>buffer_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </eq>
                    <neq>
                        <name>buffer_slice_pitch</name>                 <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>buffer_slice_pitch</name>             <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>buffer_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </neq>
                    <neq>
                        <name>host_slice_pitch</name>                   <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>host_slice_pitch</name>               <mult>
                                                                            <name>region[1]</name>
                                                                            <name>host_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>host_slice_pitch</name>
                                <name>host_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </eq>
                    <neq>
                        <name>host_slice_pitch</name>                   <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>host_slice_pitch</name>               <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>host_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1. -->
            <!-- CL_INVALID_OPERATION if clEnqueueReadBuffer is called on buffer which has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS.-->
            <!-- CL_INVALID_OPERATION if clEnqueueWriteBuffer is called on buffer which has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS.-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1">
            <proto><type>cl_int</type>                                  <name>clEnqueueWriteBufferRect</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_write</name></param>
            <param>const <type>size_t</type>*                           <name>buffer_origin</name></param>
            <param>const <type>size_t</type>*                           <name>host_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>buffer_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>buffer_slice_pitch</name></param>
            <param><type>size_t</type>                                  <name>host_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>host_slice_pitch</name></param>
            <param>const <type>void</type>*                             <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>buffer_origin</name>                      <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>host_origin</name>                        <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if the region being read or written specified by (buffer_origin, region, buffer_row_pitch, buffer_slice_pitch) is out of bounds. -->
            <if>
                <or>
                    <array_len_ls>
                        <name>buffer_origin</name>                      <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>host_origin</name>                        <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then> <!-- not sure if this is right error-->
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </neq>
                    <ls>
                        <name>buffer_row_pitch</name>                   <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </neq>
                    <ls>
                        <name>host_row_pitch</name>                     <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </neq>
                    <neq>
                        <name>buffer_slice_pitch</name>                 <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>buffer_slice_pitch</name>             <mult>
                                                                            <name>region[1]</name>
                                                                            <name>buffer_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>buffer_slice_pitch</name>
                                <name>buffer_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </eq>
                    <neq>
                        <name>buffer_slice_pitch</name>                 <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>buffer_slice_pitch</name>             <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>buffer_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </neq>
                    <neq>
                        <name>host_slice_pitch</name>                   <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>host_slice_pitch</name>               <mult>
                                                                            <name>region[1]</name>
                                                                            <name>host_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>host_slice_pitch</name>
                                <name>host_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </eq>
                    <neq>
                        <name>host_slice_pitch</name>                   <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>host_slice_pitch</name>               <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>host_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1. -->
            <!-- CL_INVALID_OPERATION if clEnqueueReadBuffer is called on buffer which has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS.-->
            <!-- CL_INVALID_OPERATION if clEnqueueWriteBuffer is called on buffer which has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS.-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_buffer</name></param>
            <param><type>cl_mem</type>                                  <name>dst_buffer</name></param>
            <param><type>size_t</type>                                  <name>src_offset</name></param>
            <param><type>size_t</type>                                  <name>dst_offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="src_buffer"/>
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_buffer"/>
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="src_buffer"/>
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_buffer"/>
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_INVALID_VALUE if src_offset, dst_offset, size, src_offset + size or dst_offset + size require accessing elements outside the src_buffer and dst_buffer buffer objects respectively. -->
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if src_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1. -->
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if dst_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1. -->
            <!--CL_MEM_COPY_OVERLAP if src_buffer and dst_buffer are the same buffer or sub-buffer object and the source and destination regions overlap or if src_buffer and dst_buffer are different sub-buffers of the same associated buffer object and they overlap. The regions overlap if src_offset ≤ dst_offset ≤ src_offset + size - 1 or if dst_offset ≤ src_offset ≤ dst_offset + size - 1. -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1">
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyBufferRect</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_buffer</name></param>
            <param><type>cl_mem</type>                                  <name>dst_buffer</name></param>
            <param>const <type>size_t</type>*                           <name>src_origin</name></param>
            <param>const <type>size_t</type>*                           <name>dst_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>src_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>src_slice_pitch</name></param>
            <param><type>size_t</type>                                  <name>dst_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>dst_slice_pitch</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="src_buffer"/>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_buffer"/>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="src_buffer"/>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_buffer"/>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>src_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>dst_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>src_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>dst_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>src_row_pitch</name>                      <literal>0</literal>
                    </neq>
                    <ls>
                        <name>src_row_pitch</name>                      <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>dst_row_pitch</name>                      <literal>0</literal>
                    </neq>
                    <ls>
                        <name>dst_row_pitch</name>                      <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>src_row_pitch</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>src_slice_pitch</name>                    <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>src_slice_pitch</name>                <mult>
                                                                            <name>region[1]</name>
                                                                            <name>src_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>src_slice_pitch</name>
                                <name>src_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>src_row_pitch</name>                      <literal>0</literal>
                    </eq>
                    <neq>
                        <name>src_slice_pitch</name>                    <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>src_slice_pitch</name>                <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>src_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>dst_row_pitch</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>dst_slice_pitch</name>                    <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>dst_slice_pitch</name>                <mult>
                                                                            <name>region[1]</name>
                                                                            <name>dst_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>dst_slice_pitch</name>
                                <name>dst_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>dst_row_pitch</name>                      <literal>0</literal>
                    </eq>
                    <neq>
                        <name>dst_slice_pitch</name>                    <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>dst_slice_pitch</name>                <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>dst_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>dst_buffer</name>                         <name>src_buffer</name>
                    </eq>
                    <or>
                        <neq>
                            <max>
                                <name>dst_row_pitch</name>
                                <name>region[0]</name>
                            </max>                                      <max>
                                                                            <name>src_row_pitch</name>
                                                                            <name>region[0]</name>
                                                                        </max>
                        </neq>
                        <neq>
                            <max>
                                <name>dst_slice_pitch</name>
                                <mult>
                                    <max>
                                        <name>dst_row_pitch</name>
                                        <name>region[0]</name>
                                    </max>
                                    <name>region[1]</name>
                                </mult>
                            </max>                                      <max>
                                                                            <name>src_slice_pitch</name>
                                                                            <mult>
                                                                                <max>
                                                                                    <name>src_row_pitch</name>
                                                                                    <name>region[0]</name>
                                                                                </max>
                                                                                <name>region[1]</name>
                                                                            </mult>
                                                                        </max>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if (src_origin, region, src_row_pitch, src_slice_pitch) or (dst_origin, region, dst_row_pitch, dst_slice_pitch) require accessing elements outside the src_buffer and dst_buffer buffer objects respectively. -->
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if src_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1. -->
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if dst_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1. -->
            <!--CL_MEM_COPY_OVERLAP if src_buffer and dst_buffer are the same buffer or sub-buffer object and the source and destination regions overlap or if src_buffer and dst_buffer are different sub-buffers of the same associated buffer object and they overlap. The regions overlap if src_offset ≤ dst_offset ≤ src_offset + size - 1 or if dst_offset ≤ src_offset ≤ dst_offset + size - 1. -->
        </command>

    <!-- 5.2.3 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clEnqueueFillBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param>const <type>void</type>*                             <name>pattern</name></param>
            <param><type>size_t</type>                                  <name>pattern_size</name></param>
            <param><type>size_t</type>                                  <name>offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <!-- CL_INVALID_VALUE if offset or offset + size require accessing elements outside the buffer buffer object respectively. -->
            <if>
                <or>
                    <eq>
                        <name>pattern</name>                            <literal>NULL</literal>
                    </eq>
                    <not>
                        <or>
                            <eq>
                                <name>pattern_size</name>               <literal>1</literal>
                            </eq>
                            <eq>
                                <name>pattern_size</name>               <literal>2</literal>
                            </eq>
                            <eq>
                                <name>pattern_size</name>               <literal>4</literal>
                            </eq>
                            <eq>
                                <name>pattern_size</name>               <literal>8</literal>
                            </eq>
                            <eq>
                                <name>pattern_size</name>               <literal>16</literal>
                            </eq>
                            <eq>
                                <name>pattern_size</name>               <literal>32</literal>
                            </eq>
                            <eq>
                                <name>pattern_size</name>               <literal>64</literal>
                            </eq>
                            <eq>
                                <name>pattern_size</name>               <literal>128</literal>
                            </eq>
                        </or>
                    </not>
                </or>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>pattern</name>                                <name>pattern_size</name>
                </array_len_ls>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <neq>
                        <mod>
                            <name>offset</name>
                            <name>pattern_size</name>
                        </mod>                                          <literal>0</literal>
                    </neq>
                    <neq>
                        <mod>
                            <name>size</name>
                            <name>pattern_size</name>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1. -->
        </command>

    <!-- 5.2.4 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>void</type>*                                   <name>clEnqueueMapBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_map</name></param>
            <param><type>cl_map_flags</type>                            <name>map_flags</name></param>
            <param><type>size_t</type>                                  <name>offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <!-- CL_INVALID_VALUE if region being mapped given by (offset, size) is out of bounds. -->
            <if>
                <or>
                    <eq>
                        <name>size</name>                               <literal>0</literal>
                    </eq>
                    <bitfield_violation name="map_flags"/>
                    <eq>
                        <name>map_flags</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>map_flags</name>                          <literal>CL_MAP_WRITE_INVALIDATE_REGION</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_READ</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_INVALID_OPERATION if buffer has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_READ is set in map_flags or if buffer has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_WRITE or CL_MAP_WRITE_INVALIDATE_REGION is set in map_flags-->
        </command>

    <!-- 5.3.1 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_mem</type>                                  <name>clCreateImage</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param>const <type>cl_image_format</type>*                  <name>image_format</name></param>
            <param>const <type>cl_image_desc</type>*                    <name>image_desc</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_USE_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_COPY_HOST_PTR</literal>
                    </bit_and>
                </or>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>image_format</name>                           <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <array_len_ls>
                    <name>image_format</name>                           <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <eq>
                    <name>image_desc</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <if>
                <array_len_ls>
                    <name>image_desc</name>                             <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <!-- if values specified in image_format are not valid OR 
            if a 2D image is created from a buffer and the row pitch and base address alignment does not follow the rules described for creating a 2D image from a buffer OR
            if a 2D image is created from a 2D image object and the rules described above are not followed -->
            <if>
                <struct_violation name="image_format" param="context, image_desc"/>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <!-- if values specified in image_desc are not valid -->
            <if>
                <struct_violation name="image_desc" param="context, host_ptr, image_format"/>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <!-- if image dimensions specified in image_desc exceed the maximum image dimensions described in the Device Queries table for all devices in context.-->
            <if>
                <struct_violation name="image_desc" param="context"/>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <!-- if an image is being created from another memory object and flags are not compatible -->
            <if>
                <struct_violation name="image_desc" param="flags"/>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- if an image is being created from host_ptr and it is too short -->
            <if>
                <struct_violation name="image_desc" param="host_ptr, image_format"/>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </eq>
                        <or>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </or>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <and>
                            <not>
                                <bit_and>
                                    <name>flags</name>                  <literal>CL_MEM_USE_HOST_PTR</literal>
                                </bit_and>
                            </not>
                            <not>
                                <bit_and>
                                    <name>flags</name>                  <literal>CL_MEM_COPY_HOST_PTR</literal>
                                </bit_and>
                            </not>
                        </and>
                    </and>
                </or>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if there are no devices in context that support image_format. -->
            <!-- CL_INVALID_OPERATION if there are no devices in context that support images (i.e. CL_DEVICE_IMAGE_SUPPORT specified in the Device Queries table is CL_FALSE). -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_3_0">
            <proto><type>cl_mem</type>                                  <name>clCreateImageWithProperties</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>const <type>cl_mem_properties</type>*                <name>properties</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param>const <type>cl_image_format</type>*                  <name>image_format</name></param>
            <param>const <type>cl_image_desc</type>*                    <name>image_desc</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <list_violation name="properties"/>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROPERTY</value>
            </then>
            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_USE_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_COPY_HOST_PTR</literal>
                    </bit_and>
                </or>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>image_format</name>                           <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <array_len_ls>
                    <name>image_format</name>                           <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <eq>
                    <name>image_desc</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <if>
                <array_len_ls>
                    <name>image_desc</name>                             <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <!-- if values specified in image_format are not valid OR 
            if a 2D image is created from a buffer and the row pitch and base address alignment does not follow the rules described for creating a 2D image from a buffer OR
            if a 2D image is created from a 2D image object and the rules described above are not followed -->
            <if>
                <struct_violation name="image_format" param="context, image_desc"/>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <!-- if values specified in image_desc are not valid -->
            <if>
                <struct_violation name="image_desc" param="context, host_ptr, image_format"/>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <!-- if image dimensions specified in image_desc exceed the maximum image dimensions described in the Device Queries table for all devices in context.-->
            <if>
                <struct_violation name="image_desc" param="context"/>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <!-- if an image is being created from another memory object and flags are not compatible -->
            <if>
                <struct_violation name="image_desc" param="flags"/>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- if an image is being created from host_ptr and it is too short -->
            <if>
                <struct_violation name="image_desc" param="host_ptr, image_format"/>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </eq>
                        <or>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </or>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <and>
                            <not>
                                <bit_and>
                                    <name>flags</name>                  <literal>CL_MEM_USE_HOST_PTR</literal>
                                </bit_and>
                            </not>
                            <not>
                                <bit_and>
                                    <name>flags</name>                  <literal>CL_MEM_COPY_HOST_PTR</literal>
                                </bit_and>
                            </not>
                        </and>
                    </and>
                </or>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if there are no devices in context that support image_format. -->
            <!-- CL_INVALID_OPERATION if there are no devices in context that support images (i.e. CL_DEVICE_IMAGE_SUPPORT specified in the Device Queries table is CL_FALSE). -->
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED">
            <proto><type>cl_mem</type>                                  <name>clCreateImage2D</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param>const <type>cl_image_format</type>*                  <name>image_format</name></param>
            <param><type>size_t</type>                                  <name>image_width</name></param>
            <param><type>size_t</type>                                  <name>image_height</name></param>
            <param><type>size_t</type>                                  <name>image_row_pitch</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if> <!-- 0 is valid here-->
                <bitfield_violation name="flags"/>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                </or>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>image_format</name>                           <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <array_len_ls>
                    <name>image_format</name>                           <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <struct_violation name="image_format"/>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>image_width</name>                        <literal>0</literal>
                    </eq>
                    <eq>
                        <name>image_height</name>                       <literal>0</literal>
                    </eq>
                    <and>
                        <eq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </eq>
                        <neq>
                            <name>image_row_pitch</name>                <literal>0</literal>
                        </neq>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <gt>
                            <name>image_row_pitch</name>                <literal>0</literal>
                        </gt>
                        <ls>
                            <name>image_row_pitch</name>                <mult>
                                                                            <name>image_width</name>
                                                                            <literal_list>image_format</literal_list>
                                                                        </mult>
                        </ls>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <!--<neq>-->
                        <!--    <name>image_row_pitch</name>                <literal>0</literal>-->
                        <!--</neq>-->
                        <neq>
                            <mod>
                                <name>image_row_pitch</name>
                                <literal_list>image_format</literal_list>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </and>
                </or>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <!-- CL_INVALID_IMAGE_SIZE if image_width or image_height are 0 or if they exceed the maximum values specified in CL_DEVICE_IMAGE2D_MAX_WIDTH or CL_DEVICE_IMAGE2D_MAX_HEIGHT respectively for all devices in context or if values specified by image_row_pitch do not follow rules described in the argument description above.
            <if>
                <each_of array="context" elements="cl_device">
                    <or>
                        <gt>
                            <name>image_width</name>                    <query object="cl_device" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <name>image_height</name>                   <query object="cl_device" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                    </or>
                </each_of>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>-->
            <if>
                <or>
                    <and>
                        <eq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </eq>
                        <or>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </or>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <and>
                            <not>
                                <bit_and>
                                    <name>flags</name>                  <literal>CL_MEM_USE_HOST_PTR</literal>
                                </bit_and>
                            </not>
                            <not>
                                <bit_and>
                                    <name>flags</name>                  <literal>CL_MEM_COPY_HOST_PTR</literal>
                                </bit_and>
                            </not>
                        </and>
                    </and>
                </or>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if there are no devices in context that support image_format. -->
            <!-- CL_INVALID_OPERATION if there are no devices in context that support images (i.e. CL_DEVICE_IMAGE_SUPPORT specified in the Device Queries table is CL_FALSE). -->
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED">
            <proto><type>cl_mem</type>                                  <name>clCreateImage3D</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param>const <type>cl_image_format</type>*                  <name>image_format</name></param>
            <param><type>size_t</type>                                  <name>image_width</name></param>
            <param><type>size_t</type>                                  <name>image_height</name></param>
            <param><type>size_t</type>                                  <name>image_depth</name></param>
            <param><type>size_t</type>                                  <name>image_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>image_slice_pitch</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if> <!-- 0 is valid here-->
                <bitfield_violation name="flags"/>
            </if>
            <then>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                </or>
            </if>    <then>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>image_format</name>                           <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <array_len_ls>
                    <name>image_format</name>                           <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <struct_violation name="image_format"/>
            </if>
            <then>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>image_width</name>                        <literal>0</literal>
                    </eq>
                    <eq>
                        <name>image_height</name>                       <literal>0</literal>
                    </eq>
                    <ls>
                        <name>image_depth</name>                        <literal>2</literal>
                    </ls>
                    <and>
                        <eq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </eq>
                        <neq>
                            <name>image_row_pitch</name>                <literal>0</literal>
                        </neq>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <gt>
                            <name>image_row_pitch</name>                <literal>0</literal>
                        </gt>
                        <ls>
                            <name>image_row_pitch</name>                <mult>
                                                                            <name>image_width</name>
                                                                            <literal_list>image_format</literal_list>
                                                                        </mult>
                        </ls>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <!--<neq>-->
                        <!--    <name>image_row_pitch</name>                <literal>0</literal>-->
                        <!--</neq>-->
                        <neq>
                            <mod>
                                <name>image_row_pitch</name>
                                <literal_list>image_format</literal_list>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </and>
                    <and>
                        <eq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </eq>
                        <neq>
                            <name>image_slice_pitch</name>              <literal>0</literal>
                        </neq>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <neq>
                            <name>image_row_pitch</name>                <literal>0</literal>
                        </neq>
                        <gt>
                            <name>image_slice_pitch</name>              <literal>0</literal>
                        </gt>
                        <ls>
                            <name>image_slice_pitch</name>              <mult>
                                                                            <name>image_height</name>
                                                                            <name>image_row_pitch</name>
                                                                        </mult>
                        </ls>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>image_row_pitch</name>                <literal>0</literal>
                        </eq>
                        <gt>
                            <name>image_slice_pitch</name>              <literal>0</literal>
                        </gt>
                        <ls>
                            <name>image_slice_pitch</name>              <mult>
                                                                            <name>image_height</name>
                                                                            <mult>
                                                                                <name>image_width</name>
                                                                                <literal_list>image_format</literal_list>
                                                                            </mult>
                                                                        </mult>
                        </ls>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <!--<neq>-->
                        <!--    <name>image_slice_pitch</name>              <literal>0</literal>-->
                        <!--</neq>-->
                        <neq>
                            <name>image_row_pitch</name>                <literal>0</literal>
                        </neq>
                        <neq>
                            <mod>
                                <name>image_slice_pitch</name>
                                <name>image_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <!--<neq>-->
                        <!--    <name>image_slice_pitch</name>              <literal>0</literal>-->
                        <!--</neq>-->
                        <eq>
                            <name>image_row_pitch</name>                <literal>0</literal>
                        </eq>
                        <neq>
                            <mod>
                                <name>image_slice_pitch</name>
                                <mult>
                                    <name>image_width</name>
                                    <literal_list>image_format</literal_list>
                                </mult>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </and>
                </or>
            </if>
            <then>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <!-- CL_INVALID_IMAGE_SIZE if image_width or image_height are 0 or if image_depth ≤ 1, or if they exceed the maximum values specified in CL_DEVICE_IMAGE3D_MAX_WIDTH, CL_DEVICE_IMAGE3D_MAX_HEIGHT or CL_DEVICE_IMAGE3D_MAX_DEPTH respectively for all devices in context, or if values specified by image_row_pitch and image_slice_pitch do not follow rules described in the argument description above. -->
            <if>
                <or>
                    <and>
                        <eq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </eq>
                        <or>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </or>
                    </and>
                    <and>
                        <neq>
                            <name>host_ptr</name>                       <literal>NULL</literal>
                        </neq>
                        <and>
                            <not>
                                <bit_and>
                                    <name>flags</name>                  <literal>CL_MEM_USE_HOST_PTR</literal>
                                </bit_and>
                            </not>
                            <not>
                                <bit_and>
                                    <name>flags</name>                  <literal>CL_MEM_COPY_HOST_PTR</literal>
                                </bit_and>
                            </not>
                        </and>
                    </and>
                </or>
            </if>
            <then>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if there are no devices in context that support image_format. -->
            <!-- CL_INVALID_OPERATION if there are no devices in context that support images (i.e. CL_DEVICE_IMAGE_SUPPORT specified in the Device Queries table is CL_FALSE). -->
        </command>

    <!-- 5.3.2 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetSupportedImageFormats</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>cl_mem_object_type</type>                      <name>image_type</name></param>
            <param><type>cl_uint</type>                                 <name>num_entries</name></param>
            <param><type>cl_image_format</type>*                        <name>image_formats</name></param>
            <param><type>cl_uint</type>*                                <name>num_image_formats</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>
                <name>clGetSupportedImageFormats</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <not>
                        <or>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_READ_WRITE</literal>
                            </bit_and>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_READ_ONLY</literal>
                            </bit_and>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_WRITE_ONLY</literal>
                            </bit_and>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_KERNEL_READ_AND_WRITE</literal>
                            </bit_and>
                        </or>
                    </not>
                    <not>
                        <or>
                            <eq>
                                <name>image_type</name>                 <literal>CL_MEM_OBJECT_IMAGE1D</literal>
                            </eq>
                            <eq>
                                <name>image_type</name>                 <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>
                            </eq>
                            <eq>
                                <name>image_type</name>                 <literal>CL_MEM_OBJECT_IMAGE2D</literal>
                            </eq>
                            <eq>
                                <name>image_type</name>                 <literal>CL_MEM_OBJECT_IMAGE3D</literal>
                            </eq>
                            <eq>
                                <name>image_type</name>                 <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>
                            </eq>
                            <eq>
                                <name>image_type</name>                 <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>
                            </eq>
                        </or>
                    </not>
                    <and>
                        <eq>
                            <name>num_entries</name>                    <literal>0</literal>
                        </eq>
                        <neq>
                            <name>image_formats</name>                  <literal>NULL</literal>
                        </neq>
                    </and>
                </or>
            </if>
            <then>
                <name>clGetSupportedImageFormats</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>image_formats</name>                      <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>image_formats</name>                      <name>num_entries</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clGetSupportedImageFormats</name>                 <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.3.3 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueReadImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_read</name></param>
            <param>const <type>size_t</type>*                           <name>origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>row_pitch</name></param>
            <param><type>size_t</type>                                  <name>slice_pitch</name></param>
            <param><type>void</type>*                                   <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="image"/>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="image"/>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>origin</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>ptr</name>                                <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <array_len_ls>
                        <name>origin</name>                             <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0. 
                If image is a 1D image array object, origin[2] must be 0. 
                If image is a 2D image object, region[2] must be 1. 
                If image is a 1D image array object, region[2] must be 1. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>origin[2]</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0.
                If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>origin[1]</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>origin[2]</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[1]</name>                          <literal>1</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if the region being read or written specified by origin and region is out of bounds -->
            <if>
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <neq>
                        <name>slice_pitch</name>                        <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_INVALID_IMAGE_SIZE if image dimensions (image width, height, specified or compute row and/or slice pitch) for image are not supported by device associated with queue. -->
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if image format (image channel order and data type) for image are not supported by device associated with queue. -->
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <or>
                    <bit_and>
                        <literal>CL_MEM_HOST_WRITE_ONLY</literal>       <query object="image" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <literal>CL_MEM_HOST_NO_ACCESS</literal>        <query object="image" property="CL_MEM_FLAGS"/>
                    </bit_and>
                </or>
            </if>
            <then>      <log>image has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_READ is set in map_flags or if image has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_WRITE or CL_MAP_WRITE_INVALIDATE_REGION is set in map_flags</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueWriteImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_write</name></param>
            <param>const <type>size_t</type>*                           <name>origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>input_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>input_slice_pitch</name></param>
            <param>const <type>void</type>*                             <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>image is not a valid image object</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="image"/>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>origin</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>ptr</name>                                <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <array_len_ls>
                        <name>origin</name>                             <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0. 
                If image is a 1D image array object, origin[2] must be 0. 
                If image is a 2D image object, region[2] must be 1. 
                If image is a 1D image array object, region[2] must be 1. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>origin[2]</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0.
                If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>origin[1]</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>origin[2]</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[1]</name>                          <literal>1</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if the region being read or written specified by origin and region is out of bounds-->
            <if>
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <neq>
                        <name>input_slice_pitch</name>                  <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_INVALID_IMAGE_SIZE if image dimensions (image width, height, specified or compute row and/or slice pitch) for image are not supported by device associated with queue. -->
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if image format (image channel order and data type) for image are not supported by device associated with queue. -->
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <or>
                    <bit_and>
                        <literal>CL_MEM_HOST_READ_ONLY</literal>        <query object="image" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <literal>CL_MEM_HOST_NO_ACCESS</literal>        <query object="image" property="CL_MEM_FLAGS"/>
                    </bit_and>
                </or>
            </if>
            <then>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_image</name></param>
            <param><type>cl_mem</type>                                  <name>dst_image</name></param>
            <param>const <type>size_t</type>*                           <name>src_origin</name></param>
            <param>const <type>size_t</type>*                           <name>dst_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="src_image"/>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_image"/>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="src_image"/>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_image"/>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <!-- CL_IMAGE_FORMAT_MISMATCH if src_image and dst_image do not use the same image format.-->
            <if>
                <or>
                    <eq>
                        <name>src_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>dst_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>src_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>dst_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0. 
                If image is a 1D image array object, origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="src_image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>src_origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="src_image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="src_image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>src_origin[1]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>src_origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[1]</name>                          <literal>1</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0. 
                If image is a 1D image array object, origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="dst_image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>dst_origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="dst_image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="dst_image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>dst_origin[1]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>dst_origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[1]</name>                          <literal>1</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if the 2D or 3D rectangular region specified by src_origin and src_origin + region refers to a region outside src_image, or if the 2D or 3D rectangular region specified by dst_origin and dst_origin + region refers to a region outside dst_image.-->
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_INVALID_IMAGE_SIZE if image dimensions (image width, height, specified or compute row and/or slice pitch) for src_image or dst_image are not supported by device associated with queue. -->
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if image format (image channel order and data type) for src_image or dst_image are not supported by device associated with queue. -->
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_OPERATION</value>
            </then>
            <!-- CL_MEM_COPY_OVERLAP if src_image and dst_image are the same image object and the source and destination regions overlap-->
        </command>

    <!-- 5.3.4 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clEnqueueFillImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param>const <type>void</type>*                             <name>fill_color</name></param>
            <param>const <type>size_t</type>*                           <name>origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="image"/>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="image"/>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>fill_color</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>origin</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <!-- limits on fill_color - see spec-->
            <if>
                <or>
                    <array_len_ls>
                        <name>origin</name>                             <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0. 
                If image is a 1D image array object, origin[2] must be 0. 
                If image is a 2D image object, region[2] must be 1. 
                If image is a 1D image array object, region[2] must be 1. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>origin[2]</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0.
                If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>origin[1]</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>origin[2]</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[1]</name>                          <literal>1</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if the region being filled as specified by origin and region is out of bounds.-->
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_INVALID_IMAGE_SIZE if image dimensions (image width, height, specified or compute row and/or slice pitch) for image are not supported by device associated with queue. -->
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if image format (image channel order and data type) for image are not supported by device associated with queue. -->
        </command>

    <!-- 5.3.5 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyImageToBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_image</name></param>
            <param><type>cl_mem</type>                                  <name>dst_buffer</name></param>
            <param>const <type>size_t</type>*                           <name>src_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>dst_offset</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>src_image is not a valid image object</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>dst_buffer is not a valid buffer object</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <!-- CL_INVALID_MEM_OBJECT if src_image is a 1D image buffer object created from dst_buffer. -->
            <if>
                <object_not_in object="command_queue" in="src_image"/>
            </if>
            <then>      <log>context associated with command_queue and src_image are not the same</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_buffer"/>
            </if>
            <then>      <log>context associated with command_queue and dst_buffer are not the same</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>src_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>src_origin or region is NULL</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>src_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>src_origin or region is too short</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>the values in region cannot be 0</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0. 
                If image is a 1D image array object, origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="src_image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>src_origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>      <log>values in src_origin and region do not follow rules for 2D image or 1D image array object</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="src_image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="src_image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>src_origin[1]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>src_origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[1]</name>                          <literal>1</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>      <log>values in src_origin and region do not follow rules for 1D image or 1D image buffer object</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if the 1D, 2D or 3D rectangular region specified by src_origin and src_origin + region refers to a region outside src_image, or if the region specified by dst_offset and dst_offset + dst_cb to a region outside dst_buffer.-->
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if dst_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1-->
            <!-- CL_INVALID_IMAGE_SIZE if image dimensions (image width, height, specified or compute row and/or slice pitch) for src_image or dst_image are not supported by device associated with queue. -->
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if image format (image channel order and data type) for src_image or dst_image are not supported by device associated with queue. -->
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyBufferToImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_buffer</name></param>
            <param><type>cl_mem</type>                                  <name>dst_image</name></param>
            <param><type>size_t</type>                                  <name>src_offset</name></param>
            <param>const <type>size_t</type>*                           <name>dst_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="src_buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>src_buffer is not a valid buffer object</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>dst_image is not a valid image object</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <!-- CL_INVALID_MEM_OBJECT if dst_image is a 1D image buffer object created from src_buffer. -->
            <if>
                <object_not_in object="command_queue" in="src_buffer"/>
            </if>
            <then>      <log>context associated with command_queue and src_buffer are not the same</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_image"/>
            </if>
            <then>      <log>context associated with command_queue and dst_image are not the same</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>dst_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>dst_origin or region is NULL</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>dst_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>dst_origin or region is too short</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>the values in region cannot be 0</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0. 
                If image is a 1D image array object, origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="dst_image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>dst_origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>      <log>values in dst_origin and region do not follow rules for 2D image or 1D image array object</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="dst_image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="dst_image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>dst_origin[1]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>dst_origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[1]</name>                          <literal>1</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>      <log>values in dst_origin and region do not follow rules for 1D image or 1D image buffer object</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if the 1D, 2D or 3D rectangular region specified by dst_origin and dst_origin + region refer to a region outside dst_image, or if the region specified by src_offset and src_offset + src_cb refer to a region outside src_buffer.-->
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <!-- CL_MISALIGNED_SUB_BUFFER_OFFSET if src_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1-->
            <!-- CL_INVALID_IMAGE_SIZE if image dimensions (image width, height, specified or compute row and/or slice pitch) for dst_image or dst_image are not supported by device associated with queue. -->
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if image format (image channel order and data type) for dst_image or dst_image are not supported by device associated with queue. -->
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

    <!-- 5.3.6 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>void</type>*                                   <name>clEnqueueMapImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_map</name></param>
            <param><type>cl_map_flags</type>                            <name>map_flags</name></param>
            <param>const <type>size_t</type>*                           <name>origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>*                                 <name>image_row_pitch</name></param>
            <param><type>size_t</type>*                                 <name>image_slice_pitch</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>image is not a valid image object</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="image"/>
            </if>
            <then>      <log>context associated with command_queue and image are not the same</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <bitfield_violation name="map_flags"/>
                    <eq>
                        <name>map_flags</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>values specified in map_flags are not valid</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>map_flags</name>                          <literal>CL_MAP_WRITE_INVALIDATE_REGION</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_READ</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>values specified in map_flags are not compatible</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>origin</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>origin or region is NULL</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <array_len_ls>
                        <name>origin</name>                             <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>origin or region is too short</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>the values in region cannot be 0</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0. 
                If image is a 1D image array object, origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>      <log>values in origin and region do not follow rules for 2D image or 1D image array object</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <or>
                    <and>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                        <neq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                        </neq>
                    </and>
                    <neq>
                        <name>origin[1]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>origin[2]</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>region[1]</name>                          <literal>1</literal>
                    </neq>
                    <neq>
                        <name>region[2]</name>                          <literal>1</literal>
                    </neq>
                </or>
            </if>
            <then>      <log>values in origin and region do not follow rules for 1D image or 1D image buffer object</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if region being mapped given by (origin, origin + region) is out of bounds -->
            <if>
                <eq>
                    <name>image_row_pitch</name>                        <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>image_row_pitch is NULL</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <not>
                        <and>
                            <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                            <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                            <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                        </and>
                    </not>
                    <eq>
                        <name>image_slice_pitch</name>                  <literal>NULL</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>image is a 3D image, 1D or 2D image array object and image_slice_pitch is NULL</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- CL_INVALID_IMAGE_SIZE if image dimensions (image width, height, specified or compute row and/or slice pitch) for image are not supported by device associated with queue.-->
            <!-- CL_IMAGE_FORMAT_NOT_SUPPORTED if image format (image channel order and data type) for image are not supported by device associated with queue-->
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <or>
                        <bit_and>
                            <literal>CL_MEM_HOST_WRITE_ONLY</literal>   <query object="image" property="CL_MEM_FLAGS"/>
                        </bit_and>
                        <bit_and>
                            <literal>CL_MEM_HOST_NO_ACCESS</literal>    <query object="image" property="CL_MEM_FLAGS"/>
                        </bit_and>
                    </or>
                    <bit_and>
                        <name>map_flags</name>                          <literal>CL_MAP_READ</literal>
                    </bit_and>
                </and>
            </if>
            <then>      <log>image has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_READ is set in map_flags</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <or>
                        <bit_and>
                            <literal>CL_MEM_HOST_READ_ONLY</literal>    <query object="image" property="CL_MEM_FLAGS"/>
                        </bit_and>
                        <bit_and>
                            <literal>CL_MEM_HOST_NO_ACCESS</literal>    <query object="image" property="CL_MEM_FLAGS"/>
                        </bit_and>
                    </or>
                    <or>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE_INVALIDATE_REGION</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>image has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_WRITE or CL_MAP_WRITE_INVALIDATE_REGION is set in map_flags</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <!-- CL_INVALID_OPERATION if mapping would lead to overlapping regions being mapped for writing -->
        </command>

    <!-- 5.3.7 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetImageInfo</name></proto>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param><type>cl_image_info</type>                           <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetImageInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetImageInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetImageInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>image is not a valid image object</log>
                <name>clGetImageInfo</name>                             <value>CL_INVALID_MEM_OBJECT</value>
            </then>
        </command>

    <!-- 5.4.1 -->

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_mem</type>                                  <name>clCreatePipe</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>cl_uint</type>                                 <name>pipe_packet_size</name></param>
            <param><type>cl_uint</type>                                 <name>pipe_max_packets</name></param>
            <param>const <type>cl_pipe_properties</type>*               <name>properties</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <!-- CL_INVALID_OPERATION if no devices in context support pipes -->
            <if>
                <not>
                    <or>
                        <eq>
                            <name>flags</name>                          <literal>0</literal>
                        </eq>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </or>
                </not>
            </if>
            <then>      <log>values specified in flags are not valid for pipe</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- can be changed in the future-->
                <neq>
                    <name>properties</name>                             <literal>NULL</literal>
                </neq>
            </if>
            <then>      <log>properties is not NULL</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>pipe_packet_size</name>                   <literal>0</literal>
                    </eq>
                    <eq>
                        <name>pipe_max_packets</name>                   <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>pipe_packet_size is 0 or pipe_max_packets is 0</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PIPE_SIZE</value>
            </then>
            <!--<if>
            </if>
            <then>      <log>the pipe_packet_size exceeds CL_DEVICE_PIPE_MAX_PACKET_SIZE value specified in the Device Queries table for all devices in context</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PIPE_SIZE</value>
            </then>-->
        </command>

    <!-- 5.4.2 -->

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetPipeInfo</name></proto>
            <param><type>cl_mem</type>                                  <name>pipe</name></param>
            <param><type>cl_pipe_info</type>                            <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="pipe" type="CL_MEM_OBJECT_PIPE"/>
            </if>
            <then>      <log>pipe is not a valid pipe object</log>
                <name>clGetPipeInfo</name>                              <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetPipeInfo</name>                              <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetPipeInfo</name>                              <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetPipeInfo</name>                              <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.5.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clRetainMemObject</name></proto>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>

            <if>
                <object_is_invalid name="memobj"/>
                <!--<and>
                    <object_is_invalid name="memobj" type="CL_MEM_OBJECT_BUFFER"/>
                    <object_is_invalid name="memobj" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="memobj" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="memobj" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="memobj" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="memobj" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="memobj" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>-->
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clRetainMemObject</name>                          <value>CL_INVALID_MEM_OBJECT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clReleaseMemObject</name></proto>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>

            <if>
                <object_is_invalid name="memobj"/>
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clReleaseMemObject</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetMemObjectDestructorCallback</name></proto>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_mem memobj, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <object_is_invalid name="memobj"/>
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clSetMemObjectDestructorCallback</name>           <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <eq>
                    <name>pfn_notify</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>pfn_notify is NULL</log>
                <name>clSetMemObjectDestructorCallback</name>           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.5.2 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueUnmapMemObject</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>
            <param><type>void</type>*                                   <name>mapped_ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="memobj"/>
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <not>
                    <object_is_invalid name="memobj" type="CL_MEM_OBJECT_PIPE"/>
                </not>
            </if>
            <then>      <log>memobj is a pipe object</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <!-- not possible without state
            CL_INVALID_VALUE if mapped_ptr is not a valid pointer returned by clEnqueueMapBuffer or clEnqueueMapImage for memobj -->
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="memobj"/>
            </if>
            <then>      <log>context associated with command_queue and memobj are not the same</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

    <!-- 5.5.4 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueMigrateMemObjects</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_mem_objects</name></param>
            <param>const <type>cl_mem</type>*                           <name>mem_objects</name></param>
            <param><type>cl_mem_migration_flags</type>                  <name>flags</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and> 
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>num_mem_objects</name>                    <literal>0</literal>
                    </eq>
                    <eq>
                        <name>mem_objects</name>                        <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>num_mem_objects is zero or if mem_objects is NULL</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>mem_objects</name>                            <name>num_mem_objects</name>
                </array_len_ls>
            </if>
            <then>      <log>mem_objects is too short</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <any_invalid array="mem_objects" elements="num_mem_objects"/>
            </if>
            <then>      <log>some of the memory objects in mem_objects is not a valid memory object</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <any_object_not_in array="mem_objects" elements="num_mem_objects" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and memory objects in mem_objects are not the same</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <bitfield_violation name="flags"/> <!-- 0 is valid here-->
            </if>
            <then>      <log>flags is not 0 and is not any of the valid values</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal> 
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
        </command>

    <!-- 5.5.5 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetMemObjectInfo</name></proto>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>
            <param><type>cl_mem_info</type>                             <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="memobj"/>
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clGetMemObjectInfo</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetMemObjectInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetMemObjectInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetMemObjectInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.6.1 -->

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>void</type>*                                   <name>clSVMAlloc</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_svm_mem_flags</type>                        <name>flags</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>alignment</name></param>

            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_SVM_ATOMICS</literal>
                        </bit_and>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_SVM_FINE_GRAIN_BUFFER</literal>
                            </bit_and>
                        </not>
                    </and>
                </or>
            </if>
            <then>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>size</name>                               <literal>0</literal>
                    </eq>
                    <!-- size is > CL_DEVICE_MAX_MEM_ALLOC_SIZE value for any device in context-->
                    <and> <!-- alignment is the minimum alignment in bytes that is required for the newly created buffers memory region. It must be a power of two up to the largest data type supported by the OpenCL device. For the full profile, the largest data type is long16. For the embedded profile, it is long16 if the device supports 64-bit integers; otherwise it is int16. If alignment is 0, a default alignment will be used that is equal to the size of largest data type supported by the OpenCL implementation-->
                        <neq>
                            <name>alignment</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>alignment</name>                      <literal>1</literal>
                        </neq>
                        <neq>
                            <name>alignment</name>                      <literal>2</literal>
                        </neq>
                        <neq>
                            <name>alignment</name>                      <literal>4</literal>
                        </neq>
                        <neq>
                            <name>alignment</name>                      <literal>8</literal>
                        </neq>
                        <neq>
                            <name>alignment</name>                      <literal>16</literal>
                        </neq>
                        <neq>
                            <name>alignment</name>                      <literal>32</literal>
                        </neq>
                        <neq>
                            <name>alignment</name>                      <literal>64</literal>
                        </neq>
                        <neq> <!-- this can still provide fail for embedded devices-->
                            <name>alignment</name>                      <literal>128</literal>
                        </neq>
                    </and>
                </or>
            </if>
            <then>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>void</type>                                    <name>clSVMFree</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>void</type>*                                   <name>svm_pointer</name></param>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMFree</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_svm_pointers</name></param>
            <param><type>void</type>*                                   <name>svm_pointers</name>[]</param>
            <param>void (CL_CALLBACK*                                   <name>pfn_free_func</name>)(cl_command_queue queue, cl_uint num_svm_pointers, void* svm_pointers[], void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <or>
                    <and>
                        <eq>
                            <name>num_svm_pointers</name>               <literal>0</literal>
                        </eq>
                        <neq>
                            <name>svm_pointers</name>                   <literal>NULL</literal>
                        </neq>
                    </and>
                    <and>
                        <neq>
                            <name>num_svm_pointers</name>               <literal>0</literal>
                        </neq>
                        <eq>
                            <name>svm_pointers</name>                   <literal>NULL</literal>
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMMemcpy</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_copy</name></param>
            <param><type>void</type>*                                   <name>dst_ptr</name></param>
            <param>const <type>void</type>*                             <name>src_ptr</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <!-- CL_INVALID_CONTEXT if the context associated with command_queue and events in event_wait_list are not the same-->
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>dst_ptr</name>                            <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>src_ptr</name>                            <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_MEM_COPY_OVERLAP if the values specified for dst_ptr, src_ptr and size result in an overlapping copy-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMMemFill</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>void</type>*                                   <name>svm_ptr</name></param>
            <param>const <type>void</type>*                             <name>pattern</name></param>
            <param><type>size_t</type>                                  <name>pattern_size</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <!-- CL_INVALID_CONTEXT if the context associated with command_queue and events in event_wait_list are not the same-->
            <if>
                <eq>
                    <name>svm_ptr</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>pattern</name>                            <literal>NULL</literal>
                    </eq>
                    <and>
                        <neq>
                            <name>pattern_size</name>                   <literal>1</literal>
                        </neq>
                        <neq>
                            <name>pattern_size</name>                   <literal>2</literal>
                        </neq>
                        <neq>
                            <name>pattern_size</name>                   <literal>4</literal>
                        </neq>
                        <neq>
                            <name>pattern_size</name>                   <literal>8</literal>
                        </neq>
                        <neq>
                            <name>pattern_size</name>                   <literal>16</literal>
                        </neq>
                        <neq>
                            <name>pattern_size</name>                   <literal>32</literal>
                        </neq>
                        <neq>
                            <name>pattern_size</name>                   <literal>64</literal>
                        </neq>
                        <neq>
                            <name>pattern_size</name>                   <literal>128</literal>
                        </neq>
                    </and>
                    <neq>
                        <mod>
                            <name>size</name>
                            <name>pattern_size</name>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if svm_ptr is not aligned to pattern_size bytes-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMMap</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_map</name></param>
            <param><type>cl_map_flags</type>                            <name>map_flags</name></param>
            <param><type>void</type>*                                   <name>svm_ptr</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <!-- CL_INVALID_CONTEXT if context associated with command_queue and events in event_wait_list are not the same-->
            <if>
                <eq>
                    <name>svm_ptr</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>size</name>                                   <literal>0</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <bitfield_violation name="map_flags"/>
                    <eq>
                        <name>map_flags</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>map_flags</name>                          <literal>CL_MAP_WRITE_INVALIDATE_REGION</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_READ</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMUnmap</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>void</type>*                                   <name>svm_ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <!-- CL_INVALID_CONTEXT if context associated with command_queue and events in event_wait_list are not the same-->
            <if>
                <eq>
                    <name>svm_ptr</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1">
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMMigrateMem</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_svm_pointers</name></param>
            <param>const <type>void</type>**                            <name>svm_pointers</name></param>
            <param>const <type>size_t</type>*                           <name>sizes</name></param>
            <param><type>cl_mem_migration_flags</type>                  <name>flags</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <!-- CL_INVALID_CONTEXT if context associated with command_queue and events in event_wait_list are not the same-->
            <if>
                <or>
                    <eq>
                        <name>num_svm_pointers</name>                   <literal>0</literal>
                    </eq>
                    <eq>
                        <name>svm_pointers</name>                       <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
        </command>

    <!-- 5.7.1 -->

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_sampler</type>                              <name>clCreateSamplerWithProperties</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>const <type>cl_sampler_properties</type>*            <name>sampler_properties</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <list_violation name="sampler_properties"/>
            </if>
            <then>
                <name>clCreateSamplerWithProperties</name>              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_OPERATION if images are not supported by any device associated with context (i.e. CL_DEVICE_IMAGE_SUPPORT specified in the Device Queries table is CL_FALSE)-->
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_2_DEPRECATED"> <!--?-->
            <proto><type>cl_sampler</type>                              <name>clCreateSampler</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_bool</type>                                 <name>normalized_coords</name></param>
            <param><type>cl_addressing_mode</type>                      <name>addressing_mode</name></param>
            <param><type>cl_filter_mode</type>                          <name>filter_mode</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <or>
                    <enum_violation name="addressing_mode"/>
                    <enum_violation name="filter_mode"/>
                </or>
            </if>
            <then>
                <name>clCreateSampler</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_OPERATION if images are not supported by any device associated with context (i.e. CL_DEVICE_IMAGE_SUPPORT specified in the Device Queries table is CL_FALSE)-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clRetainSampler</name></proto>
            <param><type>cl_sampler</type>                              <name>sampler</name></param>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clReleaseSampler</name></proto>
            <param><type>cl_sampler</type>                              <name>sampler</name></param>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetSamplerInfo</name></proto>
            <param><type>cl_sampler</type>                              <name>sampler</name></param>
            <param><type>cl_sampler_info</type>                         <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/> <!-- see the spec-->
            </if>
            <then>
                <name>clGetSamplerInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetSamplerInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetSamplerInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.8.1 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_program</type>                              <name>clCreateProgramWithSource</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_uint</type>                                 <name>count</name></param>
            <param>const <type>char</type>**                            <name>strings</name></param>
            <param>const <type>size_t</type>*                           <name>lengths</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <or>
                    <eq>
                        <name>count</name>                              <literal>0</literal>
                    </eq>
                    <eq>
                        <name>strings</name>                            <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <and>
                    <neq>
                        <name>lengths</name>                            <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>lengths</name>                            <name>count</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>strings</name>                                <name>count</name>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_nullptr array="strings" elements="count"/>
            </if>
            <then>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1">
            <proto><type>cl_program</type>                              <name>clCreateProgramWithIL</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>const <type>void</type>*                             <name>il</name></param>
            <param><type>size_t</type>                                  <name>length</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <or>
                    <eq>
                        <name>il</name>                                 <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>length</name>                             <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateProgramWithIL</name>                      <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>il</name>                                     <name>length</name>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateProgramWithIL</name>                      <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_program</type>                              <name>clCreateProgramWithBinary</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>size_t</type>*                           <name>lengths</name></param>
            <param>const <type>unsigned char</type>**                   <name>binaries</name></param>
            <param><type>cl_int</type>*                                 <name>binary_status</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <or>
                    <eq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>num_devices</name>                        <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_DEVICE if any device in device_list is not in the list of devices associated with context-->
            <if>
                <or>
                    <eq>
                        <name>lengths</name>                            <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>binaries</name>                           <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <or>
                    <array_len_ls>
                        <name>lengths</name>                            <name>num_devices</name>
                    </array_len_ls>
                    <array_len_ls>
                        <name>binaries</name>                           <name>num_devices</name>
                    </array_len_ls>
                    <and>
                        <neq>
                            <name>binary_status</name>                  <literal>NULL</literal>
                        </neq>
                        <array_len_ls>
                            <name>binary_status</name>                  <name>num_devices</name>
                        </array_len_ls>
                    </and>
                </or>
            </if>
            <then>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <any_zero array="lengths" elements="num_devices"/>
                    <any_nullptr array="binaries" elements="num_devices"/>
                </or>
            </if>
            <then>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_program</type>                              <name>clCreateProgramWithBuiltInKernels</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>char</type>*                             <name>kernel_names</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <or>
                    <eq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>num_devices</name>                        <literal>0</literal>
                    </eq>
                    <eq>
                        <name>kernel_names</name>                       <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clCreateProgramWithBuiltInKernels</name>          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>device_list</name>                            <name>num_devices</name>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateProgramWithBuiltInKernels</name>          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_DEVICE if any device in device_list is not in the list of devices associated with context-->
        </command>

    <!-- 5.8.2 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clRetainProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clReleaseProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_2_2_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_2_2_DEPRECATED">
            <proto><type>cl_int</type>                                  <name>clSetProgramReleaseCallback</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_program program, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <eq>
                    <name>pfn_notify</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clSetProgramReleaseCallback</name>                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.8.3 -->

        <command suffix="CL_API_SUFFIX__VERSION_2_2">
            <proto><type>cl_int</type>                                  <name>clSetProgramSpecializationConstant</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_uint</type>                                 <name>spec_id</name></param>
            <param><type>size_t</type>                                  <name>spec_size</name></param>
            <param>const <type>void</type>*                             <name>spec_value</name></param>
        </command>

    <!-- 5.8.4 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clBuildProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>char</type>*                             <name>options</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_program program, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <or>
                    <and>
                        <eq>
                            <name>device_list</name>                    <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_devices</name>                    <literal>0</literal>
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>device_list</name>                    <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_devices</name>                    <literal>0</literal>
                        </eq>
                    </and>
                    <and>
                        <eq>
                            <name>pfn_notify</name>                     <literal>NULL</literal>
                        </eq>
                        <neq>
                            <name>user_data</name>                      <literal>NULL</literal>
                        </neq>
                    </and>
                </or>
            </if>
            <then>
                <name>clBuildProgram</name>                             <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.8.5 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clCompileProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>char</type>*                             <name>options</name></param>
            <param><type>cl_uint</type>                                 <name>num_input_headers</name></param>
            <param>const <type>cl_program</type>*                       <name>input_headers</name></param>
            <param>const <type>char</type>**                            <name>header_include_names</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_program program, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <or>
                    <and>
                        <eq>
                            <name>device_list</name>                    <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_devices</name>                    <literal>0</literal>
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>device_list</name>                    <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_devices</name>                    <literal>0</literal>
                        </eq>
                    </and>
                    <and>
                        <eq>
                            <name>num_input_headers</name>              <literal>0</literal>
                        </eq>
                        <or>
                            <neq>
                                <name>header_include_names</name>       <literal>NULL</literal>
                            </neq>
                            <neq>
                                <name>input_headers</name>              <literal>NULL</literal>
                            </neq>
                        </or>
                    </and>
                    <and>
                        <neq>
                            <name>num_input_headers</name>              <literal>0</literal>
                        </neq>
                        <or>
                            <eq>
                                <name>header_include_names</name>       <literal>NULL</literal>
                            </eq>
                            <eq>
                                <name>input_headers</name>              <literal>NULL</literal>
                            </eq>
                        </or>
                    </and>
                    <and>
                        <eq>
                            <name>pfn_notify</name>                     <literal>NULL</literal>
                        </eq>
                        <neq>
                            <name>user_data</name>                      <literal>NULL</literal>
                        </neq>
                    </and>
                </or>
            </if>
            <then>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>device_list</name>                            <name>num_devices</name>
                </array_len_ls>
            </if>
            <then>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <and>
                    <neq>
                        <name>num_input_headers</name>                  <literal>0</literal>
                    </neq>
                    <or>
                        <array_len_ls>
                            <name>header_include_names</name>           <name>num_input_headers</name>
                        </array_len_ls>
                        <array_len_ls>
                            <name>input_headers</name>                  <name>num_input_headers</name>
                        </array_len_ls>
                    </or>
                </and>
            </if>
            <then>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_program</type>                              <name>clLinkProgram</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>char</type>*                             <name>options</name></param>
            <param><type>cl_uint</type>                                 <name>num_input_programs</name></param>
            <param>const <type>cl_program</type>*                       <name>input_programs</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_program program, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <or>
                    <and>
                        <eq>
                            <name>device_list</name>                    <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_devices</name>                    <literal>0</literal>
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>device_list</name>                    <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_devices</name>                    <literal>0</literal>
                        </eq>
                    </and>
                    <and>
                        <eq>
                            <name>num_input_programs</name>             <literal>0</literal>
                        </eq>
                        <neq>
                            <name>input_programs</name>                 <literal>NULL</literal>
                        </neq>
                    </and>
                    <and>
                        <neq>
                            <name>num_input_programs</name>             <literal>0</literal>
                        </neq>
                        <eq>
                            <name>input_programs</name>                 <literal>NULL</literal>
                        </eq>
                    </and>
                    <and>
                        <eq>
                            <name>pfn_notify</name>                     <literal>NULL</literal>
                        </eq>
                        <neq>
                            <name>user_data</name>                      <literal>NULL</literal>
                        </neq>
                    </and>
                </or>
            </if>
            <then>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>device_list</name>                            <name>num_devices</name>
                </array_len_ls>
            </if>
            <then>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>input_programs</name>                         <name>num_input_programs</name>
                </array_len_ls>
            </if>
            <then>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.8.8 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clUnloadPlatformCompiler</name></proto>
            <param><type>cl_platform_id</type>                          <name>platform</name></param>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED">
            <proto><type>cl_int</type>                                  <name>clUnloadCompiler</name></proto>
        </command>

    <!-- 5.8.9 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetProgramInfo</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_program_info</type>                         <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/> <!-- see the spec-->
            </if>
            <then>
                <name>clGetProgramInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetProgramInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetProgramInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetProgramBuildInfo</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_program_build_info</type>                   <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/> <!-- see the spec-->
            </if>
            <then>
                <name>clGetProgramBuildInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetProgramBuildInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetProgramBuildInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.9.1 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_kernel</type>                               <name>clCreateKernel</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param>const <type>char</type>*                             <name>kernel_name</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <eq>
                    <name>kernel_name</name>                            <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateKernel</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clCreateKernelsInProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_uint</type>                                 <name>num_kernels</name></param>
            <param><type>cl_kernel</type>*                              <name>kernels</name></param>
            <param><type>cl_uint</type>*                                <name>num_kernels_ret</name></param>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clRetainKernel</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clReleaseKernel</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
        </command>

    <!-- 5.9.2 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clSetKernelArg</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>arg_index</name></param>
            <param><type>size_t</type>                                  <name>arg_size</name></param>
            <param>const <type>void</type>*                             <name>arg_value</name></param>

            <!-- CL_INVALID_ARG_INDEX if arg_index is not a valid argument index-->
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>arg_value</name>                              <name>arg_size</name>
                </array_len_ls>
            </if>
            <then>
                <name>clSetKernelArg</name>                             <value>CL_INVALID_ARG_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_int</type>                                  <name>clSetKernelArgSVMPointer</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>arg_index</name></param>
            <param>const <type>void</type>*                             <name>arg_value</name></param>

            <!-- CL_INVALID_ARG_INDEX if arg_index is not a valid argument index-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0">
            <proto><type>cl_int</type>                                  <name>clSetKernelExecInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_kernel_exec_info</type>                     <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param>const <type>void</type>*                             <name>param_value</name></param>

            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls> <!-- special case, should extend here-->
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.9.3 -->

        <command suffix="CL_API_SUFFIX__VERSION_2_1">
            <proto><type>cl_kernel</type>                               <name>clCloneKernel</name></proto>
            <param><type>cl_kernel</type>                               <name>source_kernel</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>
        </command>

    <!-- 5.9.4 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetKernelInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_kernel_info</type>                          <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetKernelInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetKernelInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetKernelInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetKernelWorkGroupInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_kernel_work_group_info</type>               <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetKernelWorkGroupInfo</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetKernelWorkGroupInfo</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetKernelWorkGroupInfo</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if param_name is CL_KERNEL_GLOBAL_WORK_SIZE and device is not a custom device and kernel is not a built-in kernel-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1">
            <proto><type>cl_int</type>                                  <name>clGetKernelSubGroupInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_kernel_sub_group_info</type>                <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>input_value_size</name></param>
            <param>const <type>void</type>*                             <name>input_value</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <or>
                            <eq>
                                <name>param_name</name>                 <literal>CL_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE</literal>
                            </eq>
                            <eq>
                                <name>param_name</name>                 <literal>CL_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE</literal>
                            </eq>
                        </or>
                        <or>
                            <eq>
                                <name>input_value_size</name>           <literal>0</literal>
                            </eq>
                            <neq>
                                <mod>
                                    <name>input_value_size</name>
                                    <sizeof>size_t</sizeof>
                                </mod>                                  <literal>0</literal>
                            </neq>
                            <eq>
                                <name>input_value</name>                <literal>NULL</literal>
                            </eq>
                        </or>
                    </and>
                    <and>
                        <eq> <!-- special case - size of return type depends on value of param_value_size, so that it is checked here and not in the first if by literal_list-->
                            <name>param_name</name>                     <literal>CL_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT</literal>
                        </eq>
                        <or>
                            <neq>
                                <name>input_value_size</name>           <sizeof>size_t</sizeof>
                            </neq>
                            <eq>
                                <name>input_value</name>                <literal>NULL</literal>
                            </eq>
                            <eq>
                                <name>param_value_size</name>           <literal>0</literal>
                            </eq>
                            <neq>
                                <mod>
                                    <name>param_value_size</name>
                                    <sizeof>size_t</sizeof>
                                </mod>                                  <literal>0</literal>
                            </neq>
                        </or>
                    </and>
                </or>
            </if>
            <then>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <or>
                    <array_len_ls>
                        <name>input_value</name>                        <name>input_value_size</name>
                    </array_len_ls>
                    <array_len_ls>
                        <name>param_value</name>                        <name>param_value_size</name>
                    </array_len_ls>
                </or>
            </if>
            <then>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clGetKernelArgInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>arg_index</name></param>
            <param><type>cl_kernel_arg_info</type>                      <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetKernelArgInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetKernelArgInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetKernelArgInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.10 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueNDRangeKernel</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>work_dim</name></param>
            <param>const <type>size_t</type>*                           <name>global_work_offset</name></param>
            <param>const <type>size_t</type>*                           <name>global_work_size</name></param>
            <param>const <type>size_t</type>*                           <name>local_work_size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <!-- CL_INVALID_WORK_DIMENSION if work_dim is not a valid value (i.e. a value between 1 and CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS)-->
            <if>
                <eq>
                    <name>work_dim</name>                               <literal>0</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_WORK_DIMENSION</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>global_work_size</name>                   <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>global_work_size</name>                   <name>work_dim</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <not>
                        <from version="2.1"/>
                    </not>
                    <or>
                        <eq>
                            <name>global_work_size</name>               <literal>NULL</literal>
                        </eq>
                        <any_zero array="global_work_size" elements="work_dim"/>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_GLOBAL_WORK_SIZE</value>
            </then>
            <if>
                <and>
                    <not>
                        <from version="1.1"/>
                    </not>
                    <neq>
                        <name>global_work_offset</name>                 <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_GLOBAL_OFFSET</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>global_work_offset</name>                 <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>global_work_offset</name>                 <name>work_dim</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>local_work_size</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>local_work_size</name>                    <name>work_dim</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <!-- many errors need device queries to check-->
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_2_DEPRECATED">
            <proto><type>cl_int</type>                                  <name>clEnqueueTask</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clEnqueueNativeKernel</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param>void (CL_CALLBACK*                                   <name>user_func</name>)(void*)</param>
            <param><type>void</type>*                                   <name>args</name></param>
            <param><type>size_t</type>                                  <name>cb_args</name></param>
            <param><type>cl_uint</type>                                 <name>num_mem_objects</name></param>
            <param>const <type>cl_mem</type>*                           <name>mem_list</name></param>
            <param>const <type>void</type>**                            <name>args_mem_loc</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <eq>
                    <name>user_func</name>                              <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>args</name>                           <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>cb_args</name>                        <literal>0</literal>
                        </gt>
                    </and>
                    <and>
                        <eq>
                            <name>args</name>                           <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_mem_objects</name>                <literal>0</literal>
                        </gt>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>args</name>                               <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>cb_args</name>                            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <gt>
                        <name>num_mem_objects</name>                    <literal>0</literal>
                    </gt>
                    <or>
                        <eq>
                            <name>mem_list</name>                       <literal>NULL</literal>
                        </eq>
                        <eq>
                            <name>args_mem_loc</name>                   <literal>NULL</literal>
                        </eq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>num_mem_objects</name>                    <literal>0</literal>
                    </eq>
                    <or>
                        <neq>
                            <name>mem_list</name>                       <literal>NULL</literal>
                        </neq>
                        <neq>
                            <name>args_mem_loc</name>                   <literal>NULL</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>args</name>                               <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>args</name>                               <name>cb_args</name>
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <gt>
                        <name>num_mem_objects</name>                    <literal>0</literal>
                    </gt>
                    <or>
                        <array_len_ls>
                            <name>mem_list</name>                       <name>num_mem_objects</name>
                        </array_len_ls>
                        <array_len_ls>
                            <name>args_mem_loc</name>                   <name>num_mem_objects</name>
                        </array_len_ls>
                    </or>
                </and>
            </if>
            <then>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
        </command>

    <!-- 5.11 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_1">
            <proto><type>cl_event</type>                                <name>clCreateUserEvent</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1">
            <proto><type>cl_int</type>                                  <name>clSetUserEventStatus</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
            <param><type>cl_int</type>                                  <name>execution_status</name></param>

            <if>
                <and>
                    <neq>
                        <name>execution_status</name>                   <literal>CL_COMPLETE</literal>
                    </neq>
                    <gt>
                        <name>execution_status</name>                   <literal>-1</literal>
                    </gt>
                </and>
            </if>
            <then>
                <name>clSetUserEventStatus</name>                       <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_OPERATION if the execution_status for event has already been changed by a previous call to clSetUserEventStatus-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clWaitForEvents</name></proto>
            <param><type>cl_uint</type>                                 <name>num_events</name></param>
            <param>const <type>cl_event</type>*                         <name>event_list</name></param>

            <if>
                <or>
                    <eq>
                        <name>num_events</name>                         <literal>0</literal>
                    </eq>
                    <eq>
                        <name>event_list</name>                         <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clWaitForEvents</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <array_len_ls>
                    <name>event_list</name>                             <name>num_events</name>
                </array_len_ls>
            </if>
            <then>
                <name>clWaitForEvents</name>                            <value>CL_INVALID_EVENT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetEventInfo</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
            <param><type>cl_event_info</type>                           <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetEventInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetEventInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetEventInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1">
            <proto><type>cl_int</type>                                  <name>clSetEventCallback</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
            <param><type>cl_int</type>                                  <name>command_exec_callback_type</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_event_notify</name>)(cl_event event, cl_int event_command_status, void *user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <or>
                    <eq>
                        <name>pfn_event_notify</name>                   <literal>NULL</literal>
                    </eq>
                    <and>
                        <neq>
                            <name>command_exec_callback_type</name>     <literal>CL_SUBMITTED</literal>
                        </neq>
                        <neq>
                            <name>command_exec_callback_type</name>     <literal>CL_RUNNING</literal>
                        </neq>
                        <neq>
                            <name>command_exec_callback_type</name>     <literal>CL_COMPLETE</literal>
                        </neq>
                    </and>
                </or>
            </if>
            <then>
                <name>clSetEventCallback</name>                         <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clRetainEvent</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clReleaseEvent</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
        </command>

    <!-- 5.12 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clEnqueueMarkerWithWaitList</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueMarkerWithWaitList</name>                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueMarkerWithWaitList</name>                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED">
            <proto><type>cl_int</type>                                  <name>clEnqueueMarker</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <eq>
                    <name>event</name>                                  <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clEnqueueMarker</name>                            <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED">
            <proto><type>cl_int</type>                                  <name>clEnqueueWaitForEvents</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_events</name></param>
            <param>const <type>cl_event</type>*                         <name>event_list</name></param>

            <if>
                <or>
                    <eq>
                        <name>num_events</name>                         <literal>0</literal>
                    </eq>
                    <eq>
                        <name>event_list</name>                         <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>
                <name>clEnqueueWaitForEvents</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>event_list</name>                             <name>num_events</name>
                </array_len_ls>
            </if>
            <then>
                <name>clEnqueueWaitForEvents</name>                     <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2">
            <proto><type>cl_int</type>                                  <name>clEnqueueBarrierWithWaitList</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <or>
                    <and>
                        <eq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </eq>
                        <gt>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </gt>
                    </and>
                    <and>
                        <neq>
                            <name>event_wait_list</name>                <literal>NULL</literal>
                        </neq>
                        <eq>
                            <name>num_events_in_wait_list</name>        <literal>0</literal> 
                        </eq>
                    </and>
                </or>
            </if>
            <then>
                <name>clEnqueueBarrierWithWaitList</name>               <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- event objects in event_wait_list are not valid events-->
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name> 
                    </array_len_ls>
                </and>
            </if>
            <then>
                <name>clEnqueueBarrierWithWaitList</name>               <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED">
            <proto><type>cl_int</type>                                  <name>clEnqueueBarrier</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
        </command>

    <!-- 5.14 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clGetEventProfilingInfo</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
            <param><type>cl_profiling_info</type>                       <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetEventProfilingInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetEventProfilingInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetEventProfilingInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.15 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clFlush</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0">
            <proto><type>cl_int</type>                                  <name>clFinish</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
        </command>
    </commands>

</registry>
